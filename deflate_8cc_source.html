<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.6"/>
<title>Tomography: deflate.cc Source File</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo.png"/></td>
  <td style="padding-left: 0.5em;">
   <div id="projectname">Tomography
   </div>
   <div id="projectbrief">Tomographic reconstruction software</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.6 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&#160;List</span></a></li>
      <li><a href="globals.html"><span>File&#160;Members</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('deflate_8cc_source.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Macros</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">deflate.cc</div>  </div>
</div><!--header-->
<div class="contents">
<div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;<span class="preprocessor">#include &quot;<a class="code" href="deflate_8h.html">deflate.h</a>&quot;</span></div>
<div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;<span class="preprocessor">#include &quot;<a class="code" href="string_8h.html">string.h</a>&quot;</span></div>
<div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;</div>
<div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;<span class="comment">// ------------------- zlib-style API Definitions.</span></div>
<div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;</div>
<div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;<span class="comment">// For more compatibility with zlib, miniz.c uses unsigned long for some parameters/struct members. Beware: mz_ulong can be either 32 or 64-bits!</span></div>
<div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160;<span class="keyword">typedef</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> mz_ulong;</div>
<div class="line"><a name="l00008"></a><span class="lineno">    8</span>&#160;</div>
<div class="line"><a name="l00009"></a><span class="lineno">    9</span>&#160;<span class="preprocessor">#define MZ_ADLER32_INIT (1)</span></div>
<div class="line"><a name="l00010"></a><span class="lineno">   10</span>&#160;<span class="preprocessor"></span><span class="comment">// mz_adler32() returns the initial adler-32 value to use when called with ptr==NULL.</span></div>
<div class="line"><a name="l00011"></a><span class="lineno">   11</span>&#160;mz_ulong mz_adler32(mz_ulong adler, <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *ptr, <span class="keywordtype">size_t</span> buf_len);</div>
<div class="line"><a name="l00012"></a><span class="lineno">   12</span>&#160;</div>
<div class="line"><a name="l00013"></a><span class="lineno">   13</span>&#160;<span class="preprocessor">#define MZ_CRC32_INIT (0)</span></div>
<div class="line"><a name="l00014"></a><span class="lineno">   14</span>&#160;<span class="preprocessor"></span><span class="comment">// mz_crc32() returns the initial CRC-32 value to use when called with ptr==NULL.</span></div>
<div class="line"><a name="l00015"></a><span class="lineno">   15</span>&#160;mz_ulong mz_crc32(mz_ulong crc, <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *ptr, <span class="keywordtype">size_t</span> buf_len);</div>
<div class="line"><a name="l00016"></a><span class="lineno">   16</span>&#160;</div>
<div class="line"><a name="l00017"></a><span class="lineno">   17</span>&#160;<span class="comment">// Compression strategies.</span></div>
<div class="line"><a name="l00018"></a><span class="lineno">   18</span>&#160;<span class="keyword">enum</span> { MZ_DEFAULT_STRATEGY = 0, MZ_FILTERED = 1, MZ_HUFFMAN_ONLY = 2, MZ_RLE = 3, MZ_FIXED = 4 };</div>
<div class="line"><a name="l00019"></a><span class="lineno">   19</span>&#160;</div>
<div class="line"><a name="l00020"></a><span class="lineno">   20</span>&#160;<span class="comment">// ------------------- Types and macros</span></div>
<div class="line"><a name="l00021"></a><span class="lineno">   21</span>&#160;</div>
<div class="line"><a name="l00022"></a><span class="lineno">   22</span>&#160;<span class="keyword">typedef</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> mz_uint8;</div>
<div class="line"><a name="l00023"></a><span class="lineno">   23</span>&#160;<span class="keyword">typedef</span> <span class="keywordtype">signed</span> <span class="keywordtype">short</span> mz_int16;</div>
<div class="line"><a name="l00024"></a><span class="lineno">   24</span>&#160;<span class="keyword">typedef</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">short</span> mz_uint16;</div>
<div class="line"><a name="l00025"></a><span class="lineno">   25</span>&#160;<span class="keyword">typedef</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> mz_uint32;</div>
<div class="line"><a name="l00026"></a><span class="lineno">   26</span>&#160;<span class="keyword">typedef</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> mz_uint;</div>
<div class="line"><a name="l00027"></a><span class="lineno">   27</span>&#160;<span class="keyword">typedef</span> <span class="keywordtype">long</span> <span class="keywordtype">long</span> mz_int64;</div>
<div class="line"><a name="l00028"></a><span class="lineno">   28</span>&#160;<span class="keyword">typedef</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> <span class="keywordtype">long</span> mz_uint64;</div>
<div class="line"><a name="l00029"></a><span class="lineno">   29</span>&#160;<span class="keyword">typedef</span> <span class="keywordtype">int</span> mz_bool;</div>
<div class="line"><a name="l00030"></a><span class="lineno">   30</span>&#160;</div>
<div class="line"><a name="l00031"></a><span class="lineno">   31</span>&#160;<span class="preprocessor">#define MZ_FALSE (0)</span></div>
<div class="line"><a name="l00032"></a><span class="lineno">   32</span>&#160;<span class="preprocessor"></span><span class="preprocessor">#define MZ_TRUE (1)</span></div>
<div class="line"><a name="l00033"></a><span class="lineno">   33</span>&#160;<span class="preprocessor"></span><span class="preprocessor">#define MZ_MACRO_END while (0)</span></div>
<div class="line"><a name="l00034"></a><span class="lineno">   34</span>&#160;<span class="preprocessor"></span></div>
<div class="line"><a name="l00035"></a><span class="lineno">   35</span>&#160;</div>
<div class="line"><a name="l00036"></a><span class="lineno">   36</span>&#160;<span class="comment">// ------------------- Low-level Decompression API Definitions</span></div>
<div class="line"><a name="l00037"></a><span class="lineno">   37</span>&#160;</div>
<div class="line"><a name="l00038"></a><span class="lineno">   38</span>&#160;<span class="comment">// Decompression flags used by tinfl_decompress().</span></div>
<div class="line"><a name="l00039"></a><span class="lineno">   39</span>&#160;<span class="comment">// TINFL_FLAG_PARSE_ZLIB_HEADER: If set, the input has a valid zlib header and ends with an adler32 checksum (it&#39;s a valid zlib stream). Otherwise, the input is a raw deflate stream.</span></div>
<div class="line"><a name="l00040"></a><span class="lineno">   40</span>&#160;<span class="comment">// TINFL_FLAG_HAS_MORE_INPUT: If set, there are more input bytes available beyond the end of the supplied input buffer. If clear, the input buffer contains all remaining input.</span></div>
<div class="line"><a name="l00041"></a><span class="lineno">   41</span>&#160;<span class="comment">// TINFL_FLAG_USING_NON_WRAPPING_OUTPUT_BUF: If set, the output buffer is large enough to hold the entire decompressed stream. If clear, the output buffer is at least the size of the dictionary (typically 32KB).</span></div>
<div class="line"><a name="l00042"></a><span class="lineno">   42</span>&#160;<span class="comment">// TINFL_FLAG_COMPUTE_ADLER32: Force adler-32 checksum computation of the decompressed bytes.</span></div>
<div class="line"><a name="l00043"></a><span class="lineno">   43</span>&#160;<span class="keyword">enum</span></div>
<div class="line"><a name="l00044"></a><span class="lineno">   44</span>&#160;{</div>
<div class="line"><a name="l00045"></a><span class="lineno">   45</span>&#160;  TINFL_FLAG_PARSE_ZLIB_HEADER = 1,</div>
<div class="line"><a name="l00046"></a><span class="lineno">   46</span>&#160;  TINFL_FLAG_HAS_MORE_INPUT = 2,</div>
<div class="line"><a name="l00047"></a><span class="lineno">   47</span>&#160;  TINFL_FLAG_USING_NON_WRAPPING_OUTPUT_BUF = 4,</div>
<div class="line"><a name="l00048"></a><span class="lineno">   48</span>&#160;  TINFL_FLAG_COMPUTE_ADLER32 = 8</div>
<div class="line"><a name="l00049"></a><span class="lineno">   49</span>&#160;};</div>
<div class="line"><a name="l00050"></a><span class="lineno">   50</span>&#160;</div>
<div class="line"><a name="l00051"></a><span class="lineno">   51</span>&#160;<span class="comment">// High level decompression functions:</span></div>
<div class="line"><a name="l00052"></a><span class="lineno">   52</span>&#160;<span class="comment">// tinfl_decompress_mem_to_heap() decompresses a block in memory to a heap block allocated via malloc().</span></div>
<div class="line"><a name="l00053"></a><span class="lineno">   53</span>&#160;<span class="comment">// On entry:</span></div>
<div class="line"><a name="l00054"></a><span class="lineno">   54</span>&#160;<span class="comment">//  pSrc_buf, src_buf_len: Pointer and size of the Deflate or zlib source data to decompress.</span></div>
<div class="line"><a name="l00055"></a><span class="lineno">   55</span>&#160;<span class="comment">// On return:</span></div>
<div class="line"><a name="l00056"></a><span class="lineno">   56</span>&#160;<span class="comment">//  Function returns a pointer to the decompressed data, or NULL on failure.</span></div>
<div class="line"><a name="l00057"></a><span class="lineno">   57</span>&#160;<span class="comment">//  *pOut_len will be set to the decompressed data&#39;s size, which could be larger than src_buf_len on uncompressible data.</span></div>
<div class="line"><a name="l00058"></a><span class="lineno">   58</span>&#160;<span class="comment">//  The caller must call free() on the returned block when it&#39;s no longer needed.</span></div>
<div class="line"><a name="l00059"></a><span class="lineno">   59</span>&#160;<span class="keywordtype">void</span> *tinfl_decompress_mem_to_heap(<span class="keyword">const</span> <span class="keywordtype">void</span> *pSrc_buf, <span class="keywordtype">size_t</span> src_buf_len, <span class="keywordtype">size_t</span> *pOut_len, <span class="keywordtype">int</span> flags);</div>
<div class="line"><a name="l00060"></a><span class="lineno">   60</span>&#160;</div>
<div class="line"><a name="l00061"></a><span class="lineno">   61</span>&#160;<span class="comment">// tinfl_decompress_mem_to_mem() decompresses a block in memory to another block in memory.</span></div>
<div class="line"><a name="l00062"></a><span class="lineno">   62</span>&#160;<span class="comment">// Returns TINFL_DECOMPRESS_MEM_TO_MEM_FAILED on failure, or the number of bytes written on success.</span></div>
<div class="line"><a name="l00063"></a><span class="lineno">   63</span>&#160;<span class="preprocessor">#define TINFL_DECOMPRESS_MEM_TO_MEM_FAILED ((size_t)(-1))</span></div>
<div class="line"><a name="l00064"></a><span class="lineno">   64</span>&#160;<span class="preprocessor"></span><span class="keywordtype">size_t</span> tinfl_decompress_mem_to_mem(<span class="keywordtype">void</span> *pOut_buf, <span class="keywordtype">size_t</span> out_buf_len, <span class="keyword">const</span> <span class="keywordtype">void</span> *pSrc_buf, <span class="keywordtype">size_t</span> src_buf_len, <span class="keywordtype">int</span> flags);</div>
<div class="line"><a name="l00065"></a><span class="lineno">   65</span>&#160;</div>
<div class="line"><a name="l00066"></a><span class="lineno">   66</span>&#160;<span class="comment">// tinfl_decompress_mem_to_callback() decompresses a block in memory to an internal 32KB buffer, and a user provided callback function will be called to flush the buffer.</span></div>
<div class="line"><a name="l00067"></a><span class="lineno">   67</span>&#160;<span class="comment">// Returns 1 on success or 0 on failure.</span></div>
<div class="line"><a name="l00068"></a><span class="lineno">   68</span>&#160;<span class="keyword">typedef</span> int (*tinfl_put_buf_func_ptr)(<span class="keyword">const</span> <span class="keywordtype">void</span>* pBuf, <span class="keywordtype">int</span> len, <span class="keywordtype">void</span> *pUser);</div>
<div class="line"><a name="l00069"></a><span class="lineno">   69</span>&#160;<span class="keywordtype">int</span> tinfl_decompress_mem_to_callback(<span class="keyword">const</span> <span class="keywordtype">void</span> *pIn_buf, <span class="keywordtype">size_t</span> *pIn_buf_size, tinfl_put_buf_func_ptr pPut_buf_func, <span class="keywordtype">void</span> *pPut_buf_user, <span class="keywordtype">int</span> flags);</div>
<div class="line"><a name="l00070"></a><span class="lineno">   70</span>&#160;</div>
<div class="line"><a name="l00071"></a><span class="lineno">   71</span>&#160;<span class="keyword">struct </span>tinfl_decompressor_tag; <span class="keyword">typedef</span> <span class="keyword">struct </span>tinfl_decompressor_tag tinfl_decompressor;</div>
<div class="line"><a name="l00072"></a><span class="lineno">   72</span>&#160;</div>
<div class="line"><a name="l00073"></a><span class="lineno">   73</span>&#160;<span class="comment">// Max size of LZ dictionary.</span></div>
<div class="line"><a name="l00074"></a><span class="lineno">   74</span>&#160;<span class="preprocessor">#define TINFL_LZ_DICT_SIZE 32768</span></div>
<div class="line"><a name="l00075"></a><span class="lineno">   75</span>&#160;<span class="preprocessor"></span></div>
<div class="line"><a name="l00076"></a><span class="lineno">   76</span>&#160;<span class="comment">// Return status.</span></div>
<div class="line"><a name="l00077"></a><span class="lineno">   77</span>&#160;<span class="keyword">typedef</span> <span class="keyword">enum</span></div>
<div class="line"><a name="l00078"></a><span class="lineno">   78</span>&#160;{</div>
<div class="line"><a name="l00079"></a><span class="lineno">   79</span>&#160;  TINFL_STATUS_BAD_PARAM = -3,</div>
<div class="line"><a name="l00080"></a><span class="lineno">   80</span>&#160;  TINFL_STATUS_ADLER32_MISMATCH = -2,</div>
<div class="line"><a name="l00081"></a><span class="lineno">   81</span>&#160;  TINFL_STATUS_FAILED = -1,</div>
<div class="line"><a name="l00082"></a><span class="lineno">   82</span>&#160;  TINFL_STATUS_DONE = 0,</div>
<div class="line"><a name="l00083"></a><span class="lineno">   83</span>&#160;  TINFL_STATUS_NEEDS_MORE_INPUT = 1,</div>
<div class="line"><a name="l00084"></a><span class="lineno">   84</span>&#160;  TINFL_STATUS_HAS_MORE_OUTPUT = 2</div>
<div class="line"><a name="l00085"></a><span class="lineno">   85</span>&#160;} tinfl_status;</div>
<div class="line"><a name="l00086"></a><span class="lineno">   86</span>&#160;</div>
<div class="line"><a name="l00087"></a><span class="lineno">   87</span>&#160;<span class="comment">// Initializes the decompressor to its initial state.</span></div>
<div class="line"><a name="l00088"></a><span class="lineno">   88</span>&#160;<span class="preprocessor">#define tinfl_init(r) do { (r)-&gt;m_state = 0; } MZ_MACRO_END</span></div>
<div class="line"><a name="l00089"></a><span class="lineno">   89</span>&#160;<span class="preprocessor"></span><span class="preprocessor">#define tinfl_get_adler32(r) (r)-&gt;m_check_adler32</span></div>
<div class="line"><a name="l00090"></a><span class="lineno">   90</span>&#160;<span class="preprocessor"></span></div>
<div class="line"><a name="l00091"></a><span class="lineno">   91</span>&#160;<span class="comment">// Main low-level decompressor coroutine function. This is the only function actually needed for decompression. All the other functions are just high-level helpers for improved usability.</span></div>
<div class="line"><a name="l00092"></a><span class="lineno">   92</span>&#160;<span class="comment">// This is a universal API, i.e. it can be used as a building block to build any desired higher level decompression API. In the limit case, it can be called once per every byte input or output.</span></div>
<div class="line"><a name="l00093"></a><span class="lineno">   93</span>&#160;tinfl_status tinfl_decompress(tinfl_decompressor *r, <span class="keyword">const</span> mz_uint8 *pIn_buf_next, <span class="keywordtype">size_t</span> *pIn_buf_size, mz_uint8 *pOut_buf_start, mz_uint8 *pOut_buf_next, <span class="keywordtype">size_t</span> *pOut_buf_size, <span class="keyword">const</span> mz_uint32 decomp_flags);</div>
<div class="line"><a name="l00094"></a><span class="lineno">   94</span>&#160;</div>
<div class="line"><a name="l00095"></a><span class="lineno">   95</span>&#160;<span class="comment">// Internal/private bits follow.</span></div>
<div class="line"><a name="l00096"></a><span class="lineno">   96</span>&#160;<span class="keyword">enum</span></div>
<div class="line"><a name="l00097"></a><span class="lineno">   97</span>&#160;{</div>
<div class="line"><a name="l00098"></a><span class="lineno">   98</span>&#160;  TINFL_MAX_HUFF_TABLES = 3, TINFL_MAX_HUFF_SYMBOLS_0 = 288, TINFL_MAX_HUFF_SYMBOLS_1 = 32, TINFL_MAX_HUFF_SYMBOLS_2 = 19,</div>
<div class="line"><a name="l00099"></a><span class="lineno">   99</span>&#160;  TINFL_FAST_LOOKUP_BITS = 10, TINFL_FAST_LOOKUP_SIZE = 1 &lt;&lt; TINFL_FAST_LOOKUP_BITS</div>
<div class="line"><a name="l00100"></a><span class="lineno">  100</span>&#160;};</div>
<div class="line"><a name="l00101"></a><span class="lineno">  101</span>&#160;</div>
<div class="line"><a name="l00102"></a><span class="lineno">  102</span>&#160;<span class="keyword">typedef</span> <span class="keyword">struct</span></div>
<div class="line"><a name="l00103"></a><span class="lineno">  103</span>&#160;{</div>
<div class="line"><a name="l00104"></a><span class="lineno">  104</span>&#160;  mz_uint8 m_code_size[TINFL_MAX_HUFF_SYMBOLS_0];</div>
<div class="line"><a name="l00105"></a><span class="lineno">  105</span>&#160;  mz_int16 m_look_up[TINFL_FAST_LOOKUP_SIZE], m_tree[TINFL_MAX_HUFF_SYMBOLS_0 * 2];</div>
<div class="line"><a name="l00106"></a><span class="lineno">  106</span>&#160;} tinfl_huff_table;</div>
<div class="line"><a name="l00107"></a><span class="lineno">  107</span>&#160;</div>
<div class="line"><a name="l00108"></a><span class="lineno">  108</span>&#160;<span class="keyword">struct </span>tinfl_decompressor_tag</div>
<div class="line"><a name="l00109"></a><span class="lineno">  109</span>&#160;{</div>
<div class="line"><a name="l00110"></a><span class="lineno">  110</span>&#160;  mz_uint32 m_state, m_num_bits, m_zhdr0, m_zhdr1, m_z_adler32, m_final, m_type, m_check_adler32, m_dist, m_counter, m_num_extra, m_table_sizes[TINFL_MAX_HUFF_TABLES];</div>
<div class="line"><a name="l00111"></a><span class="lineno">  111</span>&#160;  mz_uint64 m_bit_buf;</div>
<div class="line"><a name="l00112"></a><span class="lineno">  112</span>&#160;  <span class="keywordtype">size_t</span> m_dist_from_out_buf_start;</div>
<div class="line"><a name="l00113"></a><span class="lineno">  113</span>&#160;  tinfl_huff_table m_tables[TINFL_MAX_HUFF_TABLES];</div>
<div class="line"><a name="l00114"></a><span class="lineno">  114</span>&#160;  mz_uint8 m_raw_header[4], m_len_codes[TINFL_MAX_HUFF_SYMBOLS_0 + TINFL_MAX_HUFF_SYMBOLS_1 + 137];</div>
<div class="line"><a name="l00115"></a><span class="lineno">  115</span>&#160;};</div>
<div class="line"><a name="l00116"></a><span class="lineno">  116</span>&#160;</div>
<div class="line"><a name="l00117"></a><span class="lineno">  117</span>&#160;<span class="comment">// ------------------- Low-level Compression API Definitions</span></div>
<div class="line"><a name="l00118"></a><span class="lineno">  118</span>&#160;</div>
<div class="line"><a name="l00119"></a><span class="lineno">  119</span>&#160;<span class="comment">// tdefl_init() compression flags logically OR&#39;d together (low 12 bits contain the max. number of probes per dictionary search):</span></div>
<div class="line"><a name="l00120"></a><span class="lineno">  120</span>&#160;<span class="comment">// TDEFL_DEFAULT_MAX_PROBES: The compressor defaults to 128 dictionary probes per dictionary search. 0=Huffman only, 1=Huffman+LZ (fastest/crap compression), 4095=Huffman+LZ (slowest/best compression).</span></div>
<div class="line"><a name="l00121"></a><span class="lineno">  121</span>&#160;<span class="keyword">enum</span></div>
<div class="line"><a name="l00122"></a><span class="lineno">  122</span>&#160;{</div>
<div class="line"><a name="l00123"></a><span class="lineno">  123</span>&#160;  TDEFL_HUFFMAN_ONLY = 0, TDEFL_DEFAULT_MAX_PROBES = 128, TDEFL_MAX_PROBES_MASK = 0xFFF</div>
<div class="line"><a name="l00124"></a><span class="lineno">  124</span>&#160;};</div>
<div class="line"><a name="l00125"></a><span class="lineno">  125</span>&#160;</div>
<div class="line"><a name="l00126"></a><span class="lineno">  126</span>&#160;<span class="comment">// TDEFL_WRITE_ZLIB_HEADER: If set, the compressor outputs a zlib header before the deflate data, and the Adler-32 of the source data at the end. Otherwise, you&#39;ll get raw deflate data.</span></div>
<div class="line"><a name="l00127"></a><span class="lineno">  127</span>&#160;<span class="comment">// TDEFL_COMPUTE_ADLER32: Always compute the adler-32 of the input data (even when not writing zlib headers).</span></div>
<div class="line"><a name="l00128"></a><span class="lineno">  128</span>&#160;<span class="comment">// TDEFL_GREEDY_PARSING_FLAG: Set to use faster greedy parsing, instead of more efficient lazy parsing.</span></div>
<div class="line"><a name="l00129"></a><span class="lineno">  129</span>&#160;<span class="comment">// TDEFL_NONDETERMINISTIC_PARSING_FLAG: Enable to decrease the compressor&#39;s initialization time to the minimum, but the output may vary from run to run given the same input (depending on the contents of memory).</span></div>
<div class="line"><a name="l00130"></a><span class="lineno">  130</span>&#160;<span class="comment">// TDEFL_RLE_MATCHES: Only look for RLE matches (matches with a distance of 1)</span></div>
<div class="line"><a name="l00131"></a><span class="lineno">  131</span>&#160;<span class="comment">// TDEFL_FILTER_MATCHES: Discards matches &lt;= 5 chars if enabled.</span></div>
<div class="line"><a name="l00132"></a><span class="lineno">  132</span>&#160;<span class="comment">// TDEFL_FORCE_ALL_STATIC_BLOCKS: Disable usage of optimized Huffman tables.</span></div>
<div class="line"><a name="l00133"></a><span class="lineno">  133</span>&#160;<span class="comment">// TDEFL_FORCE_ALL_RAW_BLOCKS: Only use raw (uncompressed) deflate blocks.</span></div>
<div class="line"><a name="l00134"></a><span class="lineno">  134</span>&#160;<span class="keyword">enum</span></div>
<div class="line"><a name="l00135"></a><span class="lineno">  135</span>&#160;{</div>
<div class="line"><a name="l00136"></a><span class="lineno">  136</span>&#160;  TDEFL_WRITE_ZLIB_HEADER             = 0x01000,</div>
<div class="line"><a name="l00137"></a><span class="lineno">  137</span>&#160;  TDEFL_COMPUTE_ADLER32               = 0x02000,</div>
<div class="line"><a name="l00138"></a><span class="lineno">  138</span>&#160;  TDEFL_GREEDY_PARSING_FLAG           = 0x04000,</div>
<div class="line"><a name="l00139"></a><span class="lineno">  139</span>&#160;  TDEFL_NONDETERMINISTIC_PARSING_FLAG = 0x08000,</div>
<div class="line"><a name="l00140"></a><span class="lineno">  140</span>&#160;  TDEFL_RLE_MATCHES                   = 0x10000,</div>
<div class="line"><a name="l00141"></a><span class="lineno">  141</span>&#160;  TDEFL_FILTER_MATCHES                = 0x20000,</div>
<div class="line"><a name="l00142"></a><span class="lineno">  142</span>&#160;  TDEFL_FORCE_ALL_STATIC_BLOCKS       = 0x40000,</div>
<div class="line"><a name="l00143"></a><span class="lineno">  143</span>&#160;  TDEFL_FORCE_ALL_RAW_BLOCKS          = 0x80000</div>
<div class="line"><a name="l00144"></a><span class="lineno">  144</span>&#160;};</div>
<div class="line"><a name="l00145"></a><span class="lineno">  145</span>&#160;</div>
<div class="line"><a name="l00146"></a><span class="lineno">  146</span>&#160;<span class="comment">// High level compression functions:</span></div>
<div class="line"><a name="l00147"></a><span class="lineno">  147</span>&#160;<span class="comment">// tdefl_compress_mem_to_heap() compresses a block in memory to a heap block allocated via malloc().</span></div>
<div class="line"><a name="l00148"></a><span class="lineno">  148</span>&#160;<span class="comment">// On entry:</span></div>
<div class="line"><a name="l00149"></a><span class="lineno">  149</span>&#160;<span class="comment">//  pSrc_buf, src_buf_len: Pointer and size of source block to compress.</span></div>
<div class="line"><a name="l00150"></a><span class="lineno">  150</span>&#160;<span class="comment">//  flags: The max match finder probes (default is 128) logically OR&#39;d against the above flags. Higher probes are slower but improve compression.</span></div>
<div class="line"><a name="l00151"></a><span class="lineno">  151</span>&#160;<span class="comment">// On return:</span></div>
<div class="line"><a name="l00152"></a><span class="lineno">  152</span>&#160;<span class="comment">//  Function returns a pointer to the compressed data, or NULL on failure.</span></div>
<div class="line"><a name="l00153"></a><span class="lineno">  153</span>&#160;<span class="comment">//  *pOut_len will be set to the compressed data&#39;s size, which could be larger than src_buf_len on uncompressible data.</span></div>
<div class="line"><a name="l00154"></a><span class="lineno">  154</span>&#160;<span class="comment">//  The caller must free() the returned block when it&#39;s no longer needed.</span></div>
<div class="line"><a name="l00155"></a><span class="lineno">  155</span>&#160;<span class="keywordtype">void</span> *tdefl_compress_mem_to_heap(<span class="keyword">const</span> <span class="keywordtype">void</span> *pSrc_buf, <span class="keywordtype">size_t</span> src_buf_len, <span class="keywordtype">size_t</span> *pOut_len, <span class="keywordtype">int</span> flags);</div>
<div class="line"><a name="l00156"></a><span class="lineno">  156</span>&#160;</div>
<div class="line"><a name="l00157"></a><span class="lineno">  157</span>&#160;<span class="comment">// tdefl_compress_mem_to_mem() compresses a block in memory to another block in memory.</span></div>
<div class="line"><a name="l00158"></a><span class="lineno">  158</span>&#160;<span class="comment">// Returns 0 on failure.</span></div>
<div class="line"><a name="l00159"></a><span class="lineno">  159</span>&#160;<span class="keywordtype">size_t</span> tdefl_compress_mem_to_mem(<span class="keywordtype">void</span> *pOut_buf, <span class="keywordtype">size_t</span> out_buf_len, <span class="keyword">const</span> <span class="keywordtype">void</span> *pSrc_buf, <span class="keywordtype">size_t</span> src_buf_len, <span class="keywordtype">int</span> flags);</div>
<div class="line"><a name="l00160"></a><span class="lineno">  160</span>&#160;</div>
<div class="line"><a name="l00161"></a><span class="lineno">  161</span>&#160;<span class="comment">// Compresses an image to a compressed PNG file in memory.</span></div>
<div class="line"><a name="l00162"></a><span class="lineno">  162</span>&#160;<span class="comment">// On entry:</span></div>
<div class="line"><a name="l00163"></a><span class="lineno">  163</span>&#160;<span class="comment">//  pImage, w, h, and num_chans describe the image to compress. num_chans may be 1, 2, 3, or 4. </span></div>
<div class="line"><a name="l00164"></a><span class="lineno">  164</span>&#160;<span class="comment">//  The image pitch in bytes per scanline will be w*num_chans. The leftmost pixel on the top scanline is stored first in memory.</span></div>
<div class="line"><a name="l00165"></a><span class="lineno">  165</span>&#160;<span class="comment">// On return:</span></div>
<div class="line"><a name="l00166"></a><span class="lineno">  166</span>&#160;<span class="comment">//  Function returns a pointer to the compressed data, or NULL on failure.</span></div>
<div class="line"><a name="l00167"></a><span class="lineno">  167</span>&#160;<span class="comment">//  *pLen_out will be set to the size of the PNG image file.</span></div>
<div class="line"><a name="l00168"></a><span class="lineno">  168</span>&#160;<span class="comment">//  The caller must free() the returned heap block (which will typically be larger than *pLen_out) when it&#39;s no longer needed.</span></div>
<div class="line"><a name="l00169"></a><span class="lineno">  169</span>&#160;<span class="keywordtype">void</span> *tdefl_write_image_to_png_file_in_memory(<span class="keyword">const</span> <span class="keywordtype">void</span> *pImage, <span class="keywordtype">int</span> w, <span class="keywordtype">int</span> h, <span class="keywordtype">int</span> num_chans, <span class="keywordtype">size_t</span> *pLen_out);</div>
<div class="line"><a name="l00170"></a><span class="lineno">  170</span>&#160;</div>
<div class="line"><a name="l00171"></a><span class="lineno">  171</span>&#160;<span class="comment">// Output stream interface. The compressor uses this interface to write compressed data. It&#39;ll typically be called TDEFL_OUT_BUF_SIZE at a time.</span></div>
<div class="line"><a name="l00172"></a><span class="lineno">  172</span>&#160;<span class="keyword">typedef</span> mz_bool (*tdefl_put_buf_func_ptr)(<span class="keyword">const</span> <span class="keywordtype">void</span>* pBuf, <span class="keywordtype">int</span> len, <span class="keywordtype">void</span> *pUser);</div>
<div class="line"><a name="l00173"></a><span class="lineno">  173</span>&#160;</div>
<div class="line"><a name="l00174"></a><span class="lineno">  174</span>&#160;<span class="comment">// tdefl_compress_mem_to_output() compresses a block to an output stream. The above helpers use this function internally.</span></div>
<div class="line"><a name="l00175"></a><span class="lineno">  175</span>&#160;mz_bool tdefl_compress_mem_to_output(<span class="keyword">const</span> <span class="keywordtype">void</span> *pBuf, <span class="keywordtype">size_t</span> buf_len, tdefl_put_buf_func_ptr pPut_buf_func, <span class="keywordtype">void</span> *pPut_buf_user, <span class="keywordtype">int</span> flags);</div>
<div class="line"><a name="l00176"></a><span class="lineno">  176</span>&#160;</div>
<div class="line"><a name="l00177"></a><span class="lineno">  177</span>&#160;<span class="keyword">const</span> <span class="keywordtype">int</span> TDEFL_MAX_HUFF_TABLES = 3, TDEFL_MAX_HUFF_SYMBOLS_0 = 288, TDEFL_MAX_HUFF_SYMBOLS_1 = 32, TDEFL_MAX_HUFF_SYMBOLS_2 = 19, TDEFL_LZ_DICT_SIZE = 32768, TDEFL_LZ_DICT_SIZE_MASK = TDEFL_LZ_DICT_SIZE - 1, TDEFL_MIN_MATCH_LEN = 3, TDEFL_MAX_MATCH_LEN = 258;</div>
<div class="line"><a name="l00178"></a><span class="lineno">  178</span>&#160;</div>
<div class="line"><a name="l00179"></a><span class="lineno">  179</span>&#160;<span class="comment">// TDEFL_OUT_BUF_SIZE MUST be large enough to hold a single entire compressed output block (using static/fixed Huffman codes).</span></div>
<div class="line"><a name="l00180"></a><span class="lineno">  180</span>&#160;<span class="keyword">enum</span> { TDEFL_LZ_CODE_BUF_SIZE = 64 * 1024, TDEFL_OUT_BUF_SIZE = (TDEFL_LZ_CODE_BUF_SIZE * 13 ) / 10, TDEFL_MAX_HUFF_SYMBOLS = 288, TDEFL_LZ_HASH_BITS = 15, TDEFL_LEVEL1_HASH_SIZE_MASK = 4095, TDEFL_LZ_HASH_SHIFT = (TDEFL_LZ_HASH_BITS + 2) / 3, TDEFL_LZ_HASH_SIZE = 1 &lt;&lt; TDEFL_LZ_HASH_BITS };</div>
<div class="line"><a name="l00181"></a><span class="lineno">  181</span>&#160;</div>
<div class="line"><a name="l00182"></a><span class="lineno">  182</span>&#160;<span class="comment">// The low-level tdefl functions below may be used directly if the above helper functions aren&#39;t flexible enough. The low-level functions don&#39;t make any heap allocations, unlike the above helper functions.</span></div>
<div class="line"><a name="l00183"></a><span class="lineno">  183</span>&#160;<span class="keyword">typedef</span> <span class="keyword">enum</span></div>
<div class="line"><a name="l00184"></a><span class="lineno">  184</span>&#160;{</div>
<div class="line"><a name="l00185"></a><span class="lineno">  185</span>&#160;  TDEFL_STATUS_BAD_PARAM = -2,</div>
<div class="line"><a name="l00186"></a><span class="lineno">  186</span>&#160;  TDEFL_STATUS_PUT_BUF_FAILED = -1,</div>
<div class="line"><a name="l00187"></a><span class="lineno">  187</span>&#160;  TDEFL_STATUS_OKAY = 0,</div>
<div class="line"><a name="l00188"></a><span class="lineno">  188</span>&#160;  TDEFL_STATUS_DONE = 1,</div>
<div class="line"><a name="l00189"></a><span class="lineno">  189</span>&#160;} tdefl_status;</div>
<div class="line"><a name="l00190"></a><span class="lineno">  190</span>&#160;</div>
<div class="line"><a name="l00191"></a><span class="lineno">  191</span>&#160;<span class="comment">// Must map to MZ_NO_FLUSH, MZ_SYNC_FLUSH, etc. enums</span></div>
<div class="line"><a name="l00192"></a><span class="lineno">  192</span>&#160;<span class="keyword">typedef</span> <span class="keyword">enum</span></div>
<div class="line"><a name="l00193"></a><span class="lineno">  193</span>&#160;{</div>
<div class="line"><a name="l00194"></a><span class="lineno">  194</span>&#160;  TDEFL_NO_FLUSH = 0,</div>
<div class="line"><a name="l00195"></a><span class="lineno">  195</span>&#160;  TDEFL_SYNC_FLUSH = 2,</div>
<div class="line"><a name="l00196"></a><span class="lineno">  196</span>&#160;  TDEFL_FULL_FLUSH = 3,</div>
<div class="line"><a name="l00197"></a><span class="lineno">  197</span>&#160;  TDEFL_FINISH = 4</div>
<div class="line"><a name="l00198"></a><span class="lineno">  198</span>&#160;} tdefl_flush;</div>
<div class="line"><a name="l00199"></a><span class="lineno">  199</span>&#160;</div>
<div class="line"><a name="l00200"></a><span class="lineno">  200</span>&#160;<span class="comment">// tdefl&#39;s compression state structure.</span></div>
<div class="line"><a name="l00201"></a><span class="lineno">  201</span>&#160;<span class="keyword">typedef</span> <span class="keyword">struct</span></div>
<div class="line"><a name="l00202"></a><span class="lineno">  202</span>&#160;{</div>
<div class="line"><a name="l00203"></a><span class="lineno">  203</span>&#160;  tdefl_put_buf_func_ptr m_pPut_buf_func;</div>
<div class="line"><a name="l00204"></a><span class="lineno">  204</span>&#160;  <span class="keywordtype">void</span> *m_pPut_buf_user;</div>
<div class="line"><a name="l00205"></a><span class="lineno">  205</span>&#160;  mz_uint m_flags, m_max_probes[2];</div>
<div class="line"><a name="l00206"></a><span class="lineno">  206</span>&#160;  <span class="keywordtype">int</span> m_greedy_parsing;</div>
<div class="line"><a name="l00207"></a><span class="lineno">  207</span>&#160;  mz_uint m_adler32, m_lookahead_pos, m_lookahead_size, m_dict_size;</div>
<div class="line"><a name="l00208"></a><span class="lineno">  208</span>&#160;  mz_uint8 *m_pLZ_code_buf, *m_pLZ_flags, *m_pOutput_buf, *m_pOutput_buf_end;</div>
<div class="line"><a name="l00209"></a><span class="lineno">  209</span>&#160;  mz_uint m_num_flags_left, m_total_lz_bytes, m_lz_code_buf_dict_pos, m_bits_in, m_bit_buffer;</div>
<div class="line"><a name="l00210"></a><span class="lineno">  210</span>&#160;  mz_uint m_saved_match_dist, m_saved_match_len, m_saved_lit, m_output_flush_ofs, m_output_flush_remaining, m_finished, m_block_index, m_wants_to_finish;</div>
<div class="line"><a name="l00211"></a><span class="lineno">  211</span>&#160;  tdefl_status m_prev_return_status;</div>
<div class="line"><a name="l00212"></a><span class="lineno">  212</span>&#160;  <span class="keyword">const</span> <span class="keywordtype">void</span> *m_pIn_buf;</div>
<div class="line"><a name="l00213"></a><span class="lineno">  213</span>&#160;  <span class="keywordtype">void</span> *m_pOut_buf;</div>
<div class="line"><a name="l00214"></a><span class="lineno">  214</span>&#160;  <span class="keywordtype">size_t</span> *m_pIn_buf_size, *m_pOut_buf_size;</div>
<div class="line"><a name="l00215"></a><span class="lineno">  215</span>&#160;  tdefl_flush m_flush;</div>
<div class="line"><a name="l00216"></a><span class="lineno">  216</span>&#160;  <span class="keyword">const</span> mz_uint8 *m_pSrc;</div>
<div class="line"><a name="l00217"></a><span class="lineno">  217</span>&#160;  <span class="keywordtype">size_t</span> m_src_buf_left, m_out_buf_ofs;</div>
<div class="line"><a name="l00218"></a><span class="lineno">  218</span>&#160;  mz_uint8 m_dict[TDEFL_LZ_DICT_SIZE + TDEFL_MAX_MATCH_LEN - 1];</div>
<div class="line"><a name="l00219"></a><span class="lineno">  219</span>&#160;  mz_uint16 m_huff_count[TDEFL_MAX_HUFF_TABLES][TDEFL_MAX_HUFF_SYMBOLS];</div>
<div class="line"><a name="l00220"></a><span class="lineno">  220</span>&#160;  mz_uint16 m_huff_codes[TDEFL_MAX_HUFF_TABLES][TDEFL_MAX_HUFF_SYMBOLS];</div>
<div class="line"><a name="l00221"></a><span class="lineno">  221</span>&#160;  mz_uint8 m_huff_code_sizes[TDEFL_MAX_HUFF_TABLES][TDEFL_MAX_HUFF_SYMBOLS];</div>
<div class="line"><a name="l00222"></a><span class="lineno">  222</span>&#160;  mz_uint8 m_lz_code_buf[TDEFL_LZ_CODE_BUF_SIZE];</div>
<div class="line"><a name="l00223"></a><span class="lineno">  223</span>&#160;  mz_uint16 m_next[TDEFL_LZ_DICT_SIZE];</div>
<div class="line"><a name="l00224"></a><span class="lineno">  224</span>&#160;  mz_uint16 m_hash[TDEFL_LZ_HASH_SIZE];</div>
<div class="line"><a name="l00225"></a><span class="lineno">  225</span>&#160;  mz_uint8 m_output_buf[TDEFL_OUT_BUF_SIZE];</div>
<div class="line"><a name="l00226"></a><span class="lineno">  226</span>&#160;} tdefl_compressor;</div>
<div class="line"><a name="l00227"></a><span class="lineno">  227</span>&#160;</div>
<div class="line"><a name="l00228"></a><span class="lineno">  228</span>&#160;<span class="comment">// Initializes the compressor.</span></div>
<div class="line"><a name="l00229"></a><span class="lineno">  229</span>&#160;<span class="comment">// There is no corresponding deinit() function because the tdefl API&#39;s do not dynamically allocate memory.</span></div>
<div class="line"><a name="l00230"></a><span class="lineno">  230</span>&#160;<span class="comment">// pBut_buf_func: If NULL, output data will be supplied to the specified callback. In this case, the user should call the tdefl_compress_buffer() API for compression.</span></div>
<div class="line"><a name="l00231"></a><span class="lineno">  231</span>&#160;<span class="comment">// If pBut_buf_func is NULL the user should always call the tdefl_compress() API.</span></div>
<div class="line"><a name="l00232"></a><span class="lineno">  232</span>&#160;<span class="comment">// flags: See the above enums (TDEFL_HUFFMAN_ONLY, TDEFL_WRITE_ZLIB_HEADER, etc.)</span></div>
<div class="line"><a name="l00233"></a><span class="lineno">  233</span>&#160;tdefl_status tdefl_init(tdefl_compressor *d, tdefl_put_buf_func_ptr pPut_buf_func, <span class="keywordtype">void</span> *pPut_buf_user, <span class="keywordtype">int</span> flags);</div>
<div class="line"><a name="l00234"></a><span class="lineno">  234</span>&#160;</div>
<div class="line"><a name="l00235"></a><span class="lineno">  235</span>&#160;<span class="comment">// Compresses a block of data, consuming as much of the specified input buffer as possible, and writing as much compressed data to the specified output buffer as possible.</span></div>
<div class="line"><a name="l00236"></a><span class="lineno">  236</span>&#160;tdefl_status tdefl_compress(tdefl_compressor *d, <span class="keyword">const</span> <span class="keywordtype">void</span> *pIn_buf, <span class="keywordtype">size_t</span> *pIn_buf_size, <span class="keywordtype">void</span> *pOut_buf, <span class="keywordtype">size_t</span> *pOut_buf_size, tdefl_flush flush);</div>
<div class="line"><a name="l00237"></a><span class="lineno">  237</span>&#160;</div>
<div class="line"><a name="l00238"></a><span class="lineno">  238</span>&#160;<span class="comment">// tdefl_compress_buffer() is only usable when the tdefl_init() is called with a non-NULL tdefl_put_buf_func_ptr.</span></div>
<div class="line"><a name="l00239"></a><span class="lineno">  239</span>&#160;<span class="comment">// tdefl_compress_buffer() always consumes the entire input buffer.</span></div>
<div class="line"><a name="l00240"></a><span class="lineno">  240</span>&#160;tdefl_status tdefl_compress_buffer(tdefl_compressor *d, <span class="keyword">const</span> <span class="keywordtype">void</span> *pIn_buf, <span class="keywordtype">size_t</span> in_buf_size, tdefl_flush flush);</div>
<div class="line"><a name="l00241"></a><span class="lineno">  241</span>&#160;</div>
<div class="line"><a name="l00242"></a><span class="lineno">  242</span>&#160;<span class="preprocessor">#include &lt;<a class="code" href="string_8h.html">string.h</a>&gt;</span></div>
<div class="line"><a name="l00243"></a><span class="lineno">  243</span>&#160;</div>
<div class="line"><a name="l00244"></a><span class="lineno">  244</span>&#160;<span class="preprocessor">#define MZ_MAX(a,b) (((a)&gt;(b))?(a):(b))</span></div>
<div class="line"><a name="l00245"></a><span class="lineno">  245</span>&#160;<span class="preprocessor"></span><span class="preprocessor">#define MZ_MIN(a,b) (((a)&lt;(b))?(a):(b))</span></div>
<div class="line"><a name="l00246"></a><span class="lineno">  246</span>&#160;<span class="preprocessor"></span><span class="preprocessor">#define MZ_CLEAR_OBJ(obj) memset(&amp;(obj), 0, sizeof(obj))</span></div>
<div class="line"><a name="l00247"></a><span class="lineno">  247</span>&#160;<span class="preprocessor"></span><span class="preprocessor">#define MZ_READ_LE16(p) *((const mz_uint16 *)(p))</span></div>
<div class="line"><a name="l00248"></a><span class="lineno">  248</span>&#160;<span class="preprocessor"></span><span class="preprocessor">#define MZ_READ_LE32(p) *((const mz_uint32 *)(p))</span></div>
<div class="line"><a name="l00249"></a><span class="lineno">  249</span>&#160;<span class="preprocessor"></span></div>
<div class="line"><a name="l00250"></a><span class="lineno">  250</span>&#160;<span class="comment">// ------------------- zlib-style API&#39;s</span></div>
<div class="line"><a name="l00251"></a><span class="lineno">  251</span>&#160;</div>
<div class="line"><a name="l00252"></a><span class="lineno">  252</span>&#160;mz_ulong mz_adler32(mz_ulong adler, <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *ptr, <span class="keywordtype">size_t</span> buf_len)</div>
<div class="line"><a name="l00253"></a><span class="lineno">  253</span>&#160;{</div>
<div class="line"><a name="l00254"></a><span class="lineno">  254</span>&#160;  mz_uint32 i, s1 = (mz_uint32)(adler &amp; 0xffff), s2 = (mz_uint32)(adler &gt;&gt; 16); <span class="keywordtype">size_t</span> block_len = buf_len % 5552;</div>
<div class="line"><a name="l00255"></a><span class="lineno">  255</span>&#160;  <span class="keywordflow">if</span> (!ptr) <span class="keywordflow">return</span> MZ_ADLER32_INIT;</div>
<div class="line"><a name="l00256"></a><span class="lineno">  256</span>&#160;  <span class="keywordflow">while</span> (buf_len) {</div>
<div class="line"><a name="l00257"></a><span class="lineno">  257</span>&#160;    <span class="keywordflow">for</span> (i = 0; i + 7 &lt; block_len; i += 8, ptr += 8) {</div>
<div class="line"><a name="l00258"></a><span class="lineno">  258</span>&#160;      s1 += ptr[0], s2 += s1; s1 += ptr[1], s2 += s1; s1 += ptr[2], s2 += s1; s1 += ptr[3], s2 += s1;</div>
<div class="line"><a name="l00259"></a><span class="lineno">  259</span>&#160;      s1 += ptr[4], s2 += s1; s1 += ptr[5], s2 += s1; s1 += ptr[6], s2 += s1; s1 += ptr[7], s2 += s1;</div>
<div class="line"><a name="l00260"></a><span class="lineno">  260</span>&#160;    }</div>
<div class="line"><a name="l00261"></a><span class="lineno">  261</span>&#160;    <span class="keywordflow">for</span> ( ; i &lt; block_len; ++i) s1 += *ptr++, s2 += s1;</div>
<div class="line"><a name="l00262"></a><span class="lineno">  262</span>&#160;    s1 %= 65521U, s2 %= 65521U; buf_len -= block_len; block_len = 5552;</div>
<div class="line"><a name="l00263"></a><span class="lineno">  263</span>&#160;  }</div>
<div class="line"><a name="l00264"></a><span class="lineno">  264</span>&#160;  <span class="keywordflow">return</span> (s2 &lt;&lt; 16) + s1;</div>
<div class="line"><a name="l00265"></a><span class="lineno">  265</span>&#160;}</div>
<div class="line"><a name="l00266"></a><span class="lineno">  266</span>&#160;</div>
<div class="line"><a name="l00267"></a><span class="lineno">  267</span>&#160;<span class="comment">// Karl Malbrain&#39;s compact CRC-32. See &quot;A compact CCITT crc16 and crc32 C implementation that balances processor cache usage against speed&quot;: http://www.geocities.com/malbrain/</span></div>
<div class="line"><a name="l00268"></a><span class="lineno">  268</span>&#160;mz_ulong mz_crc32(mz_ulong crc, <span class="keyword">const</span> mz_uint8 *ptr, <span class="keywordtype">size_t</span> buf_len)</div>
<div class="line"><a name="l00269"></a><span class="lineno">  269</span>&#160;{</div>
<div class="line"><a name="l00270"></a><span class="lineno">  270</span>&#160;  <span class="keyword">static</span> <span class="keyword">const</span> mz_uint32 s_crc32[16] = { 0, 0x1db71064, 0x3b6e20c8, 0x26d930ac, 0x76dc4190, 0x6b6b51f4, 0x4db26158, 0x5005713c,</div>
<div class="line"><a name="l00271"></a><span class="lineno">  271</span>&#160;    0xedb88320, 0xf00f9344, 0xd6d6a3e8, 0xcb61b38c, 0x9b64c2b0, 0x86d3d2d4, 0xa00ae278, 0xbdbdf21c };</div>
<div class="line"><a name="l00272"></a><span class="lineno">  272</span>&#160;  mz_uint32 crcu32 = (mz_uint32)crc;</div>
<div class="line"><a name="l00273"></a><span class="lineno">  273</span>&#160;  <span class="keywordflow">if</span> (!ptr) <span class="keywordflow">return</span> MZ_CRC32_INIT;</div>
<div class="line"><a name="l00274"></a><span class="lineno">  274</span>&#160;  crcu32 = ~crcu32; <span class="keywordflow">while</span> (buf_len--) { mz_uint8 b = *ptr++; crcu32 = (crcu32 &gt;&gt; 4) ^ s_crc32[(crcu32 &amp; 0xF) ^ (b &amp; 0xF)]; crcu32 = (crcu32 &gt;&gt; 4) ^ s_crc32[(crcu32 &amp; 0xF) ^ (b &gt;&gt; 4)]; }</div>
<div class="line"><a name="l00275"></a><span class="lineno">  275</span>&#160;  <span class="keywordflow">return</span> ~crcu32;</div>
<div class="line"><a name="l00276"></a><span class="lineno">  276</span>&#160;}</div>
<div class="line"><a name="l00277"></a><span class="lineno">  277</span>&#160;</div>
<div class="line"><a name="l00278"></a><span class="lineno">  278</span>&#160;<span class="comment">// ------------------- Low-level Decompression (completely independent from all compression API&#39;s)</span></div>
<div class="line"><a name="l00279"></a><span class="lineno">  279</span>&#160;</div>
<div class="line"><a name="l00280"></a><span class="lineno">  280</span>&#160;<span class="preprocessor">#define TINFL_CR_BEGIN switch(r-&gt;m_state) { case 0:</span></div>
<div class="line"><a name="l00281"></a><span class="lineno">  281</span>&#160;<span class="preprocessor"></span><span class="preprocessor">#define TINFL_CR_RETURN(state_index, result) do { status = result; r-&gt;m_state = state_index; goto common_exit; case state_index:; } MZ_MACRO_END</span></div>
<div class="line"><a name="l00282"></a><span class="lineno">  282</span>&#160;<span class="preprocessor"></span><span class="preprocessor">#define TINFL_CR_RETURN_FOREVER(state_index, result) do { for ( ; ; ) { TINFL_CR_RETURN(state_index, result); } } MZ_MACRO_END</span></div>
<div class="line"><a name="l00283"></a><span class="lineno">  283</span>&#160;<span class="preprocessor"></span><span class="preprocessor">#define TINFL_CR_FINISH }</span></div>
<div class="line"><a name="l00284"></a><span class="lineno">  284</span>&#160;<span class="preprocessor"></span></div>
<div class="line"><a name="l00285"></a><span class="lineno">  285</span>&#160;<span class="comment">// TODO: If the caller has indicated that there&#39;s no more input, and we attempt to read beyond the input buf, then something is wrong with the input because the inflator never</span></div>
<div class="line"><a name="l00286"></a><span class="lineno">  286</span>&#160;<span class="comment">// reads ahead more than it needs to. Currently TINFL_GET_BYTE() pads the end of the stream with 0&#39;s in this scenario.</span></div>
<div class="line"><a name="l00287"></a><span class="lineno">  287</span>&#160;<span class="preprocessor">#define TINFL_GET_BYTE(state_index, c) do { \</span></div>
<div class="line"><a name="l00288"></a><span class="lineno">  288</span>&#160;<span class="preprocessor">  if (pIn_buf_cur &gt;= pIn_buf_end) { \</span></div>
<div class="line"><a name="l00289"></a><span class="lineno">  289</span>&#160;<span class="preprocessor">    for ( ; ; ) { \</span></div>
<div class="line"><a name="l00290"></a><span class="lineno">  290</span>&#160;<span class="preprocessor">      if (decomp_flags &amp; TINFL_FLAG_HAS_MORE_INPUT) { \</span></div>
<div class="line"><a name="l00291"></a><span class="lineno">  291</span>&#160;<span class="preprocessor">        TINFL_CR_RETURN(state_index, TINFL_STATUS_NEEDS_MORE_INPUT); \</span></div>
<div class="line"><a name="l00292"></a><span class="lineno">  292</span>&#160;<span class="preprocessor">        if (pIn_buf_cur &lt; pIn_buf_end) { \</span></div>
<div class="line"><a name="l00293"></a><span class="lineno">  293</span>&#160;<span class="preprocessor">          c = *pIn_buf_cur++; \</span></div>
<div class="line"><a name="l00294"></a><span class="lineno">  294</span>&#160;<span class="preprocessor">          break; \</span></div>
<div class="line"><a name="l00295"></a><span class="lineno">  295</span>&#160;<span class="preprocessor">        } \</span></div>
<div class="line"><a name="l00296"></a><span class="lineno">  296</span>&#160;<span class="preprocessor">      } else { \</span></div>
<div class="line"><a name="l00297"></a><span class="lineno">  297</span>&#160;<span class="preprocessor">        c = 0; \</span></div>
<div class="line"><a name="l00298"></a><span class="lineno">  298</span>&#160;<span class="preprocessor">        break; \</span></div>
<div class="line"><a name="l00299"></a><span class="lineno">  299</span>&#160;<span class="preprocessor">      } \</span></div>
<div class="line"><a name="l00300"></a><span class="lineno">  300</span>&#160;<span class="preprocessor">    } \</span></div>
<div class="line"><a name="l00301"></a><span class="lineno">  301</span>&#160;<span class="preprocessor">  } else c = *pIn_buf_cur++; } MZ_MACRO_END</span></div>
<div class="line"><a name="l00302"></a><span class="lineno">  302</span>&#160;<span class="preprocessor"></span></div>
<div class="line"><a name="l00303"></a><span class="lineno">  303</span>&#160;<span class="preprocessor">#define TINFL_NEED_BITS(state_index, n) do { mz_uint c; TINFL_GET_BYTE(state_index, c); bit_buf |= (((mz_uint64)c) &lt;&lt; num_bits); num_bits += 8; } while (num_bits &lt; (mz_uint)(n))</span></div>
<div class="line"><a name="l00304"></a><span class="lineno">  304</span>&#160;<span class="preprocessor"></span><span class="preprocessor">#define TINFL_SKIP_BITS(state_index, n) do { if (num_bits &lt; (mz_uint)(n)) { TINFL_NEED_BITS(state_index, n); } bit_buf &gt;&gt;= (n); num_bits -= (n); } MZ_MACRO_END</span></div>
<div class="line"><a name="l00305"></a><span class="lineno">  305</span>&#160;<span class="preprocessor"></span><span class="preprocessor">#define TINFL_GET_BITS(state_index, b, n) do { if (num_bits &lt; (mz_uint)(n)) { TINFL_NEED_BITS(state_index, n); } b = bit_buf &amp; ((1 &lt;&lt; (n)) - 1); bit_buf &gt;&gt;= (n); num_bits -= (n); } MZ_MACRO_END</span></div>
<div class="line"><a name="l00306"></a><span class="lineno">  306</span>&#160;<span class="preprocessor"></span></div>
<div class="line"><a name="l00307"></a><span class="lineno">  307</span>&#160;<span class="comment">// TINFL_HUFF_BITBUF_FILL() is only used rarely, when the number of bytes remaining in the input buffer falls below 2.</span></div>
<div class="line"><a name="l00308"></a><span class="lineno">  308</span>&#160;<span class="comment">// It reads just enough bytes from the input stream that are needed to decode the next Huffman code (and absolutely no more). It works by trying to fully decode a</span></div>
<div class="line"><a name="l00309"></a><span class="lineno">  309</span>&#160;<span class="comment">// Huffman code by using whatever bits are currently present in the bit buffer. If this fails, it reads another byte, and tries again until it succeeds or until the</span></div>
<div class="line"><a name="l00310"></a><span class="lineno">  310</span>&#160;<span class="comment">// bit buffer contains &gt;=15 bits (deflate&#39;s max. Huffman code size).</span></div>
<div class="line"><a name="l00311"></a><span class="lineno">  311</span>&#160;<span class="preprocessor">#define TINFL_HUFF_BITBUF_FILL(state_index, pHuff) \</span></div>
<div class="line"><a name="l00312"></a><span class="lineno">  312</span>&#160;<span class="preprocessor">  do { \</span></div>
<div class="line"><a name="l00313"></a><span class="lineno">  313</span>&#160;<span class="preprocessor">    temp = (pHuff)-&gt;m_look_up[bit_buf &amp; (TINFL_FAST_LOOKUP_SIZE - 1)]; \</span></div>
<div class="line"><a name="l00314"></a><span class="lineno">  314</span>&#160;<span class="preprocessor">    if (temp &gt;= 0) { \</span></div>
<div class="line"><a name="l00315"></a><span class="lineno">  315</span>&#160;<span class="preprocessor">      code_len = temp &gt;&gt; 9; \</span></div>
<div class="line"><a name="l00316"></a><span class="lineno">  316</span>&#160;<span class="preprocessor">      if ((code_len) &amp;&amp; (num_bits &gt;= code_len)) \</span></div>
<div class="line"><a name="l00317"></a><span class="lineno">  317</span>&#160;<span class="preprocessor">      break; \</span></div>
<div class="line"><a name="l00318"></a><span class="lineno">  318</span>&#160;<span class="preprocessor">    } else if (num_bits &gt; TINFL_FAST_LOOKUP_BITS) { \</span></div>
<div class="line"><a name="l00319"></a><span class="lineno">  319</span>&#160;<span class="preprocessor">       code_len = TINFL_FAST_LOOKUP_BITS; \</span></div>
<div class="line"><a name="l00320"></a><span class="lineno">  320</span>&#160;<span class="preprocessor">       do { \</span></div>
<div class="line"><a name="l00321"></a><span class="lineno">  321</span>&#160;<span class="preprocessor">          temp = (pHuff)-&gt;m_tree[~temp + ((bit_buf &gt;&gt; code_len++) &amp; 1)]; \</span></div>
<div class="line"><a name="l00322"></a><span class="lineno">  322</span>&#160;<span class="preprocessor">       } while ((temp &lt; 0) &amp;&amp; (num_bits &gt;= (code_len + 1))); if (temp &gt;= 0) break; \</span></div>
<div class="line"><a name="l00323"></a><span class="lineno">  323</span>&#160;<span class="preprocessor">    } TINFL_GET_BYTE(state_index, c); bit_buf |= (((mz_uint64)c) &lt;&lt; num_bits); num_bits += 8; \</span></div>
<div class="line"><a name="l00324"></a><span class="lineno">  324</span>&#160;<span class="preprocessor">  } while (num_bits &lt; 15);</span></div>
<div class="line"><a name="l00325"></a><span class="lineno">  325</span>&#160;<span class="preprocessor"></span></div>
<div class="line"><a name="l00326"></a><span class="lineno">  326</span>&#160;<span class="comment">// TINFL_HUFF_DECODE() decodes the next Huffman coded symbol. It&#39;s more complex than you would initially expect because the zlib API expects the decompressor to never read</span></div>
<div class="line"><a name="l00327"></a><span class="lineno">  327</span>&#160;<span class="comment">// beyond the final byte of the deflate stream. (In other words, when this macro wants to read another byte from the input, it REALLY needs another byte in order to fully</span></div>
<div class="line"><a name="l00328"></a><span class="lineno">  328</span>&#160;<span class="comment">// decode the next Huffman code.) Handling this properly is particularly important on raw deflate (non-zlib) streams, which aren&#39;t followed by a byte aligned adler-32.</span></div>
<div class="line"><a name="l00329"></a><span class="lineno">  329</span>&#160;<span class="comment">// The slow path is only executed at the very end of the input buffer.</span></div>
<div class="line"><a name="l00330"></a><span class="lineno">  330</span>&#160;<span class="preprocessor">#define TINFL_HUFF_DECODE(state_index, sym, pHuff) do { \</span></div>
<div class="line"><a name="l00331"></a><span class="lineno">  331</span>&#160;<span class="preprocessor">  int temp; mz_uint code_len, c; \</span></div>
<div class="line"><a name="l00332"></a><span class="lineno">  332</span>&#160;<span class="preprocessor">  if (num_bits &lt; 15) { \</span></div>
<div class="line"><a name="l00333"></a><span class="lineno">  333</span>&#160;<span class="preprocessor">    if ((pIn_buf_end - pIn_buf_cur) &lt; 2) { \</span></div>
<div class="line"><a name="l00334"></a><span class="lineno">  334</span>&#160;<span class="preprocessor">       TINFL_HUFF_BITBUF_FILL(state_index, pHuff); \</span></div>
<div class="line"><a name="l00335"></a><span class="lineno">  335</span>&#160;<span class="preprocessor">    } else { \</span></div>
<div class="line"><a name="l00336"></a><span class="lineno">  336</span>&#160;<span class="preprocessor">       bit_buf |= (((mz_uint64)pIn_buf_cur[0]) &lt;&lt; num_bits) | (((mz_uint64)pIn_buf_cur[1]) &lt;&lt; (num_bits + 8)); pIn_buf_cur += 2; num_bits += 16; \</span></div>
<div class="line"><a name="l00337"></a><span class="lineno">  337</span>&#160;<span class="preprocessor">    } \</span></div>
<div class="line"><a name="l00338"></a><span class="lineno">  338</span>&#160;<span class="preprocessor">  } \</span></div>
<div class="line"><a name="l00339"></a><span class="lineno">  339</span>&#160;<span class="preprocessor">  if ((temp = (pHuff)-&gt;m_look_up[bit_buf &amp; (TINFL_FAST_LOOKUP_SIZE - 1)]) &gt;= 0) \</span></div>
<div class="line"><a name="l00340"></a><span class="lineno">  340</span>&#160;<span class="preprocessor">    code_len = temp &gt;&gt; 9, temp &amp;= 511; \</span></div>
<div class="line"><a name="l00341"></a><span class="lineno">  341</span>&#160;<span class="preprocessor">  else { \</span></div>
<div class="line"><a name="l00342"></a><span class="lineno">  342</span>&#160;<span class="preprocessor">    code_len = TINFL_FAST_LOOKUP_BITS; do { temp = (pHuff)-&gt;m_tree[~temp + ((bit_buf &gt;&gt; code_len++) &amp; 1)]; } while (temp &lt; 0); \</span></div>
<div class="line"><a name="l00343"></a><span class="lineno">  343</span>&#160;<span class="preprocessor">  } sym = temp; bit_buf &gt;&gt;= code_len; num_bits -= code_len; } MZ_MACRO_END</span></div>
<div class="line"><a name="l00344"></a><span class="lineno">  344</span>&#160;<span class="preprocessor"></span></div>
<div class="line"><a name="l00345"></a><span class="lineno">  345</span>&#160;tinfl_status tinfl_decompress(tinfl_decompressor *r, <span class="keyword">const</span> mz_uint8 *pIn_buf_next, <span class="keywordtype">size_t</span> *pIn_buf_size, mz_uint8 *pOut_buf_start, mz_uint8 *pOut_buf_next, <span class="keywordtype">size_t</span> *pOut_buf_size, <span class="keyword">const</span> mz_uint32 decomp_flags)</div>
<div class="line"><a name="l00346"></a><span class="lineno">  346</span>&#160;{</div>
<div class="line"><a name="l00347"></a><span class="lineno">  347</span>&#160;  <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">int</span> s_length_base[31] = { 3,4,5,6,7,8,9,10,11,13, 15,17,19,23,27,31,35,43,51,59, 67,83,99,115,131,163,195,227,258,0,0 };</div>
<div class="line"><a name="l00348"></a><span class="lineno">  348</span>&#160;  <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">int</span> s_length_extra[31]= { 0,0,0,0,0,0,0,0,1,1,1,1,2,2,2,2,3,3,3,3,4,4,4,4,5,5,5,5,0,0,0 };</div>
<div class="line"><a name="l00349"></a><span class="lineno">  349</span>&#160;  <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">int</span> s_dist_base[32] = { 1,2,3,4,5,7,9,13,17,25,33,49,65,97,129,193, 257,385,513,769,1025,1537,2049,3073,4097,6145,8193,12289,16385,24577,0,0};</div>
<div class="line"><a name="l00350"></a><span class="lineno">  350</span>&#160;  <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">int</span> s_dist_extra[32] = { 0,0,0,0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12,12,13,13};</div>
<div class="line"><a name="l00351"></a><span class="lineno">  351</span>&#160;  <span class="keyword">static</span> <span class="keyword">const</span> mz_uint8 s_length_dezigzag[19] = { 16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15 };</div>
<div class="line"><a name="l00352"></a><span class="lineno">  352</span>&#160;  <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">int</span> s_min_table_sizes[3] = { 257, 1, 4 };</div>
<div class="line"><a name="l00353"></a><span class="lineno">  353</span>&#160;</div>
<div class="line"><a name="l00354"></a><span class="lineno">  354</span>&#160;  tinfl_status status = TINFL_STATUS_FAILED; mz_uint32 num_bits, dist, counter, num_extra; mz_uint64 bit_buf;</div>
<div class="line"><a name="l00355"></a><span class="lineno">  355</span>&#160;  <span class="keyword">const</span> mz_uint8 *pIn_buf_cur = pIn_buf_next, *<span class="keyword">const</span> pIn_buf_end = pIn_buf_next + *pIn_buf_size;</div>
<div class="line"><a name="l00356"></a><span class="lineno">  356</span>&#160;  mz_uint8 *pOut_buf_cur = pOut_buf_next, *<span class="keyword">const</span> pOut_buf_end = pOut_buf_next + *pOut_buf_size;</div>
<div class="line"><a name="l00357"></a><span class="lineno">  357</span>&#160;  <span class="keywordtype">size_t</span> out_buf_size_mask = (decomp_flags &amp; TINFL_FLAG_USING_NON_WRAPPING_OUTPUT_BUF) ? (<span class="keywordtype">size_t</span>)-1 : ((pOut_buf_next - pOut_buf_start) + *pOut_buf_size) - 1, dist_from_out_buf_start;</div>
<div class="line"><a name="l00358"></a><span class="lineno">  358</span>&#160;</div>
<div class="line"><a name="l00359"></a><span class="lineno">  359</span>&#160;  <span class="comment">// Ensure the output buffer&#39;s size is a power of 2, unless the output buffer is large enough to hold the entire output file (in which case it doesn&#39;t matter).</span></div>
<div class="line"><a name="l00360"></a><span class="lineno">  360</span>&#160;  <span class="keywordflow">if</span> (((out_buf_size_mask + 1) &amp; out_buf_size_mask) || (pOut_buf_next &lt; pOut_buf_start)) { *pIn_buf_size = *pOut_buf_size = 0; <span class="keywordflow">return</span> TINFL_STATUS_BAD_PARAM; }</div>
<div class="line"><a name="l00361"></a><span class="lineno">  361</span>&#160;</div>
<div class="line"><a name="l00362"></a><span class="lineno">  362</span>&#160;  num_bits = r-&gt;m_num_bits; bit_buf = r-&gt;m_bit_buf; dist = r-&gt;m_dist; counter = r-&gt;m_counter; num_extra = r-&gt;m_num_extra; dist_from_out_buf_start = r-&gt;m_dist_from_out_buf_start;</div>
<div class="line"><a name="l00363"></a><span class="lineno">  363</span>&#160;  TINFL_CR_BEGIN</div>
<div class="line"><a name="l00364"></a><span class="lineno">  364</span>&#160;</div>
<div class="line"><a name="l00365"></a><span class="lineno">  365</span>&#160;  bit_buf = num_bits = dist = counter = num_extra = r-&gt;m_zhdr0 = r-&gt;m_zhdr1 = 0; r-&gt;m_z_adler32 = r-&gt;m_check_adler32 = 1;</div>
<div class="line"><a name="l00366"></a><span class="lineno">  366</span>&#160;  <span class="keywordflow">if</span> (decomp_flags &amp; TINFL_FLAG_PARSE_ZLIB_HEADER)</div>
<div class="line"><a name="l00367"></a><span class="lineno">  367</span>&#160;  {</div>
<div class="line"><a name="l00368"></a><span class="lineno">  368</span>&#160;    TINFL_GET_BYTE(1, r-&gt;m_zhdr0); TINFL_GET_BYTE(2, r-&gt;m_zhdr1);</div>
<div class="line"><a name="l00369"></a><span class="lineno">  369</span>&#160;    counter = (((r-&gt;m_zhdr0 * 256 + r-&gt;m_zhdr1) % 31 != 0) || (r-&gt;m_zhdr1 &amp; 32) || ((r-&gt;m_zhdr0 &amp; 15) != 8));</div>
<div class="line"><a name="l00370"></a><span class="lineno">  370</span>&#160;    <span class="keywordflow">if</span> (!(decomp_flags &amp; TINFL_FLAG_USING_NON_WRAPPING_OUTPUT_BUF)) counter |= (((1U &lt;&lt; (8U + (r-&gt;m_zhdr0 &gt;&gt; 4))) &gt; 32768U) || ((out_buf_size_mask + 1) &lt; (size_t)(1U &lt;&lt; (8U + (r-&gt;m_zhdr0 &gt;&gt; 4)))));</div>
<div class="line"><a name="l00371"></a><span class="lineno">  371</span>&#160;    <span class="keywordflow">if</span> (counter) { TINFL_CR_RETURN_FOREVER(36, TINFL_STATUS_FAILED); }</div>
<div class="line"><a name="l00372"></a><span class="lineno">  372</span>&#160;  }</div>
<div class="line"><a name="l00373"></a><span class="lineno">  373</span>&#160;</div>
<div class="line"><a name="l00374"></a><span class="lineno">  374</span>&#160;  <span class="keywordflow">do</span></div>
<div class="line"><a name="l00375"></a><span class="lineno">  375</span>&#160;  {</div>
<div class="line"><a name="l00376"></a><span class="lineno">  376</span>&#160;    TINFL_GET_BITS(3, r-&gt;m_final, 3); r-&gt;m_type = r-&gt;m_final &gt;&gt; 1;</div>
<div class="line"><a name="l00377"></a><span class="lineno">  377</span>&#160;    <span class="keywordflow">if</span> (r-&gt;m_type == 0)</div>
<div class="line"><a name="l00378"></a><span class="lineno">  378</span>&#160;    {</div>
<div class="line"><a name="l00379"></a><span class="lineno">  379</span>&#160;      TINFL_SKIP_BITS(5, num_bits &amp; 7);</div>
<div class="line"><a name="l00380"></a><span class="lineno">  380</span>&#160;      <span class="keywordflow">for</span> (counter = 0; counter &lt; 4; ++counter) { <span class="keywordflow">if</span> (num_bits) TINFL_GET_BITS(6, r-&gt;m_raw_header[counter], 8); <span class="keywordflow">else</span> TINFL_GET_BYTE(7, r-&gt;m_raw_header[counter]); }</div>
<div class="line"><a name="l00381"></a><span class="lineno">  381</span>&#160;      <span class="keywordflow">if</span> ((counter = (r-&gt;m_raw_header[0] | (r-&gt;m_raw_header[1] &lt;&lt; 8))) != (mz_uint)(0xFFFF ^ (r-&gt;m_raw_header[2] | (r-&gt;m_raw_header[3] &lt;&lt; 8)))) { TINFL_CR_RETURN_FOREVER(39, TINFL_STATUS_FAILED); }</div>
<div class="line"><a name="l00382"></a><span class="lineno">  382</span>&#160;      <span class="keywordflow">while</span> ((counter) &amp;&amp; (num_bits))</div>
<div class="line"><a name="l00383"></a><span class="lineno">  383</span>&#160;      {</div>
<div class="line"><a name="l00384"></a><span class="lineno">  384</span>&#160;        TINFL_GET_BITS(51, dist, 8);</div>
<div class="line"><a name="l00385"></a><span class="lineno">  385</span>&#160;        <span class="keywordflow">while</span> (pOut_buf_cur &gt;= pOut_buf_end) { TINFL_CR_RETURN(52, TINFL_STATUS_HAS_MORE_OUTPUT); }</div>
<div class="line"><a name="l00386"></a><span class="lineno">  386</span>&#160;        *pOut_buf_cur++ = (mz_uint8)dist;</div>
<div class="line"><a name="l00387"></a><span class="lineno">  387</span>&#160;        counter--;</div>
<div class="line"><a name="l00388"></a><span class="lineno">  388</span>&#160;      }</div>
<div class="line"><a name="l00389"></a><span class="lineno">  389</span>&#160;      <span class="keywordflow">while</span> (counter)</div>
<div class="line"><a name="l00390"></a><span class="lineno">  390</span>&#160;      {</div>
<div class="line"><a name="l00391"></a><span class="lineno">  391</span>&#160;        <span class="keywordtype">size_t</span> n; <span class="keywordflow">while</span> (pOut_buf_cur &gt;= pOut_buf_end) { TINFL_CR_RETURN(9, TINFL_STATUS_HAS_MORE_OUTPUT); }</div>
<div class="line"><a name="l00392"></a><span class="lineno">  392</span>&#160;        <span class="keywordflow">while</span> (pIn_buf_cur &gt;= pIn_buf_end)</div>
<div class="line"><a name="l00393"></a><span class="lineno">  393</span>&#160;        {</div>
<div class="line"><a name="l00394"></a><span class="lineno">  394</span>&#160;          <span class="keywordflow">if</span> (decomp_flags &amp; TINFL_FLAG_HAS_MORE_INPUT)</div>
<div class="line"><a name="l00395"></a><span class="lineno">  395</span>&#160;          {</div>
<div class="line"><a name="l00396"></a><span class="lineno">  396</span>&#160;            TINFL_CR_RETURN(38, TINFL_STATUS_NEEDS_MORE_INPUT);</div>
<div class="line"><a name="l00397"></a><span class="lineno">  397</span>&#160;          }</div>
<div class="line"><a name="l00398"></a><span class="lineno">  398</span>&#160;          <span class="keywordflow">else</span></div>
<div class="line"><a name="l00399"></a><span class="lineno">  399</span>&#160;          {</div>
<div class="line"><a name="l00400"></a><span class="lineno">  400</span>&#160;            TINFL_CR_RETURN_FOREVER(40, TINFL_STATUS_FAILED);</div>
<div class="line"><a name="l00401"></a><span class="lineno">  401</span>&#160;          }</div>
<div class="line"><a name="l00402"></a><span class="lineno">  402</span>&#160;        }</div>
<div class="line"><a name="l00403"></a><span class="lineno">  403</span>&#160;        n = MZ_MIN(MZ_MIN((<span class="keywordtype">size_t</span>)(pOut_buf_end - pOut_buf_cur), (<span class="keywordtype">size_t</span>)(pIn_buf_end - pIn_buf_cur)), counter);</div>
<div class="line"><a name="l00404"></a><span class="lineno">  404</span>&#160;        memcpy(pOut_buf_cur, pIn_buf_cur, n); pIn_buf_cur += n; pOut_buf_cur += n; counter -= (mz_uint)n;</div>
<div class="line"><a name="l00405"></a><span class="lineno">  405</span>&#160;      }</div>
<div class="line"><a name="l00406"></a><span class="lineno">  406</span>&#160;    }</div>
<div class="line"><a name="l00407"></a><span class="lineno">  407</span>&#160;    <span class="keywordflow">else</span> <span class="keywordflow">if</span> (r-&gt;m_type == 3)</div>
<div class="line"><a name="l00408"></a><span class="lineno">  408</span>&#160;    {</div>
<div class="line"><a name="l00409"></a><span class="lineno">  409</span>&#160;      TINFL_CR_RETURN_FOREVER(10, TINFL_STATUS_FAILED);</div>
<div class="line"><a name="l00410"></a><span class="lineno">  410</span>&#160;    }</div>
<div class="line"><a name="l00411"></a><span class="lineno">  411</span>&#160;    <span class="keywordflow">else</span></div>
<div class="line"><a name="l00412"></a><span class="lineno">  412</span>&#160;    {</div>
<div class="line"><a name="l00413"></a><span class="lineno">  413</span>&#160;      <span class="keywordflow">if</span> (r-&gt;m_type == 1)</div>
<div class="line"><a name="l00414"></a><span class="lineno">  414</span>&#160;      {</div>
<div class="line"><a name="l00415"></a><span class="lineno">  415</span>&#160;        mz_uint8 *p = r-&gt;m_tables[0].m_code_size; mz_uint i;</div>
<div class="line"><a name="l00416"></a><span class="lineno">  416</span>&#160;        r-&gt;m_table_sizes[0] = 288; r-&gt;m_table_sizes[1] = 32; memset(r-&gt;m_tables[1].m_code_size, 5, 32);</div>
<div class="line"><a name="l00417"></a><span class="lineno">  417</span>&#160;        <span class="keywordflow">for</span> ( i = 0; i &lt;= 143; ++i) *p++ = 8; <span class="keywordflow">for</span> ( ; i &lt;= 255; ++i) *p++ = 9; <span class="keywordflow">for</span> ( ; i &lt;= 279; ++i) *p++ = 7; <span class="keywordflow">for</span> ( ; i &lt;= 287; ++i) *p++ = 8;</div>
<div class="line"><a name="l00418"></a><span class="lineno">  418</span>&#160;      }</div>
<div class="line"><a name="l00419"></a><span class="lineno">  419</span>&#160;      <span class="keywordflow">else</span></div>
<div class="line"><a name="l00420"></a><span class="lineno">  420</span>&#160;      {</div>
<div class="line"><a name="l00421"></a><span class="lineno">  421</span>&#160;        <span class="keywordflow">for</span> (counter = 0; counter &lt; 3; counter++) { TINFL_GET_BITS(11, r-&gt;m_table_sizes[counter], <span class="stringliteral">&quot;\05\05\04&quot;</span>[counter]); r-&gt;m_table_sizes[counter] += s_min_table_sizes[counter]; }</div>
<div class="line"><a name="l00422"></a><span class="lineno">  422</span>&#160;        MZ_CLEAR_OBJ(r-&gt;m_tables[2].m_code_size); <span class="keywordflow">for</span> (counter = 0; counter &lt; r-&gt;m_table_sizes[2]; counter++) { mz_uint s; TINFL_GET_BITS(14, s, 3); r-&gt;m_tables[2].m_code_size[s_length_dezigzag[counter]] = (mz_uint8)s; }</div>
<div class="line"><a name="l00423"></a><span class="lineno">  423</span>&#160;        r-&gt;m_table_sizes[2] = 19;</div>
<div class="line"><a name="l00424"></a><span class="lineno">  424</span>&#160;      }</div>
<div class="line"><a name="l00425"></a><span class="lineno">  425</span>&#160;      <span class="keywordflow">for</span> ( ; (int)r-&gt;m_type &gt;= 0; r-&gt;m_type--)</div>
<div class="line"><a name="l00426"></a><span class="lineno">  426</span>&#160;      {</div>
<div class="line"><a name="l00427"></a><span class="lineno">  427</span>&#160;        <span class="keywordtype">int</span> tree_next, tree_cur; tinfl_huff_table *pTable;</div>
<div class="line"><a name="l00428"></a><span class="lineno">  428</span>&#160;        mz_uint i, j, used_syms, total, sym_index, next_code[17], total_syms[16]; pTable = &amp;r-&gt;m_tables[r-&gt;m_type]; MZ_CLEAR_OBJ(total_syms); MZ_CLEAR_OBJ(pTable-&gt;m_look_up); MZ_CLEAR_OBJ(pTable-&gt;m_tree);</div>
<div class="line"><a name="l00429"></a><span class="lineno">  429</span>&#160;        <span class="keywordflow">for</span> (i = 0; i &lt; r-&gt;m_table_sizes[r-&gt;m_type]; ++i) total_syms[pTable-&gt;m_code_size[i]]++;</div>
<div class="line"><a name="l00430"></a><span class="lineno">  430</span>&#160;        used_syms = 0, total = 0; next_code[0] = next_code[1] = 0;</div>
<div class="line"><a name="l00431"></a><span class="lineno">  431</span>&#160;        for (i = 1; i &lt;= 15; ++i) { used_syms += total_syms[i]; next_code[i + 1] = (total = ((total + total_syms[i]) &lt;&lt; 1)); }</div>
<div class="line"><a name="l00432"></a><span class="lineno">  432</span>&#160;        <span class="keywordflow">if</span> ((65536 != total) &amp;&amp; (used_syms &gt; 1))</div>
<div class="line"><a name="l00433"></a><span class="lineno">  433</span>&#160;        {</div>
<div class="line"><a name="l00434"></a><span class="lineno">  434</span>&#160;          TINFL_CR_RETURN_FOREVER(35, TINFL_STATUS_FAILED);</div>
<div class="line"><a name="l00435"></a><span class="lineno">  435</span>&#160;        }</div>
<div class="line"><a name="l00436"></a><span class="lineno">  436</span>&#160;        <span class="keywordflow">for</span> (tree_next = -1, sym_index = 0; sym_index &lt; r-&gt;m_table_sizes[r-&gt;m_type]; ++sym_index)</div>
<div class="line"><a name="l00437"></a><span class="lineno">  437</span>&#160;        {</div>
<div class="line"><a name="l00438"></a><span class="lineno">  438</span>&#160;          mz_uint rev_code = 0, l, cur_code, code_size = pTable-&gt;m_code_size[sym_index]; <span class="keywordflow">if</span> (!code_size) <span class="keywordflow">continue</span>;</div>
<div class="line"><a name="l00439"></a><span class="lineno">  439</span>&#160;          cur_code = next_code[code_size]++; <span class="keywordflow">for</span> (l = code_size; l &gt; 0; l--, cur_code &gt;&gt;= 1) rev_code = (rev_code &lt;&lt; 1) | (cur_code &amp; 1);</div>
<div class="line"><a name="l00440"></a><span class="lineno">  440</span>&#160;          <span class="keywordflow">if</span> (code_size &lt;= TINFL_FAST_LOOKUP_BITS) { mz_int16 k = (mz_int16)((code_size &lt;&lt; 9) | sym_index); <span class="keywordflow">while</span> (rev_code &lt; TINFL_FAST_LOOKUP_SIZE) { pTable-&gt;m_look_up[rev_code] = k; rev_code += (1 &lt;&lt; code_size); } <span class="keywordflow">continue</span>; }</div>
<div class="line"><a name="l00441"></a><span class="lineno">  441</span>&#160;          <span class="keywordflow">if</span> (0 == (tree_cur = pTable-&gt;m_look_up[rev_code &amp; (TINFL_FAST_LOOKUP_SIZE - 1)])) { pTable-&gt;m_look_up[rev_code &amp; (TINFL_FAST_LOOKUP_SIZE - 1)] = (mz_int16)tree_next; tree_cur = tree_next; tree_next -= 2; }</div>
<div class="line"><a name="l00442"></a><span class="lineno">  442</span>&#160;          rev_code &gt;&gt;= (TINFL_FAST_LOOKUP_BITS - 1);</div>
<div class="line"><a name="l00443"></a><span class="lineno">  443</span>&#160;          <span class="keywordflow">for</span> (j = code_size; j &gt; (TINFL_FAST_LOOKUP_BITS + 1); j--)</div>
<div class="line"><a name="l00444"></a><span class="lineno">  444</span>&#160;          {</div>
<div class="line"><a name="l00445"></a><span class="lineno">  445</span>&#160;            tree_cur -= ((rev_code &gt;&gt;= 1) &amp; 1);</div>
<div class="line"><a name="l00446"></a><span class="lineno">  446</span>&#160;            <span class="keywordflow">if</span> (!pTable-&gt;m_tree[-tree_cur - 1]) { pTable-&gt;m_tree[-tree_cur - 1] = (mz_int16)tree_next; tree_cur = tree_next; tree_next -= 2; } <span class="keywordflow">else</span> tree_cur = pTable-&gt;m_tree[-tree_cur - 1];</div>
<div class="line"><a name="l00447"></a><span class="lineno">  447</span>&#160;          }</div>
<div class="line"><a name="l00448"></a><span class="lineno">  448</span>&#160;          tree_cur -= ((rev_code &gt;&gt;= 1) &amp; 1); pTable-&gt;m_tree[-tree_cur - 1] = (mz_int16)sym_index;</div>
<div class="line"><a name="l00449"></a><span class="lineno">  449</span>&#160;        }</div>
<div class="line"><a name="l00450"></a><span class="lineno">  450</span>&#160;        <span class="keywordflow">if</span> (r-&gt;m_type == 2)</div>
<div class="line"><a name="l00451"></a><span class="lineno">  451</span>&#160;        {</div>
<div class="line"><a name="l00452"></a><span class="lineno">  452</span>&#160;          <span class="keywordflow">for</span> (counter = 0; counter &lt; (r-&gt;m_table_sizes[0] + r-&gt;m_table_sizes[1]); )</div>
<div class="line"><a name="l00453"></a><span class="lineno">  453</span>&#160;          {</div>
<div class="line"><a name="l00454"></a><span class="lineno">  454</span>&#160;            mz_uint s; TINFL_HUFF_DECODE(16, dist, &amp;r-&gt;m_tables[2]); <span class="keywordflow">if</span> (dist &lt; 16) { r-&gt;m_len_codes[counter++] = (mz_uint8)dist; <span class="keywordflow">continue</span>; }</div>
<div class="line"><a name="l00455"></a><span class="lineno">  455</span>&#160;            <span class="keywordflow">if</span> ((dist == 16) &amp;&amp; (!counter))</div>
<div class="line"><a name="l00456"></a><span class="lineno">  456</span>&#160;            {</div>
<div class="line"><a name="l00457"></a><span class="lineno">  457</span>&#160;              TINFL_CR_RETURN_FOREVER(17, TINFL_STATUS_FAILED);</div>
<div class="line"><a name="l00458"></a><span class="lineno">  458</span>&#160;            }</div>
<div class="line"><a name="l00459"></a><span class="lineno">  459</span>&#160;            num_extra = <span class="stringliteral">&quot;\02\03\07&quot;</span>[dist - 16]; TINFL_GET_BITS(18, s, num_extra); s += <span class="stringliteral">&quot;\03\03\013&quot;</span>[dist - 16];</div>
<div class="line"><a name="l00460"></a><span class="lineno">  460</span>&#160;            __builtin___memset_chk(r-&gt;m_len_codes + counter, (dist == 16) ? r-&gt;m_len_codes[counter - 1] : 0, s, __bos0(r-&gt;m_len_codes + counter));</div>
<div class="line"><a name="l00461"></a><span class="lineno">  461</span>&#160;            counter += s;</div>
<div class="line"><a name="l00462"></a><span class="lineno">  462</span>&#160;          }</div>
<div class="line"><a name="l00463"></a><span class="lineno">  463</span>&#160;          <span class="keywordflow">if</span> ((r-&gt;m_table_sizes[0] + r-&gt;m_table_sizes[1]) != counter)</div>
<div class="line"><a name="l00464"></a><span class="lineno">  464</span>&#160;          {</div>
<div class="line"><a name="l00465"></a><span class="lineno">  465</span>&#160;            TINFL_CR_RETURN_FOREVER(21, TINFL_STATUS_FAILED);</div>
<div class="line"><a name="l00466"></a><span class="lineno">  466</span>&#160;          }</div>
<div class="line"><a name="l00467"></a><span class="lineno">  467</span>&#160;          memcpy(r-&gt;m_tables[0].m_code_size, r-&gt;m_len_codes, r-&gt;m_table_sizes[0]); memcpy(r-&gt;m_tables[1].m_code_size, r-&gt;m_len_codes + r-&gt;m_table_sizes[0], r-&gt;m_table_sizes[1]);</div>
<div class="line"><a name="l00468"></a><span class="lineno">  468</span>&#160;        }</div>
<div class="line"><a name="l00469"></a><span class="lineno">  469</span>&#160;      }</div>
<div class="line"><a name="l00470"></a><span class="lineno">  470</span>&#160;      <span class="keywordflow">for</span> ( ; ; )</div>
<div class="line"><a name="l00471"></a><span class="lineno">  471</span>&#160;      {</div>
<div class="line"><a name="l00472"></a><span class="lineno">  472</span>&#160;        mz_uint8 *pSrc;</div>
<div class="line"><a name="l00473"></a><span class="lineno">  473</span>&#160;        <span class="keywordflow">for</span> ( ; ; )</div>
<div class="line"><a name="l00474"></a><span class="lineno">  474</span>&#160;        {</div>
<div class="line"><a name="l00475"></a><span class="lineno">  475</span>&#160;          <span class="keywordflow">if</span> (((pIn_buf_end - pIn_buf_cur) &lt; 4) || ((pOut_buf_end - pOut_buf_cur) &lt; 2))</div>
<div class="line"><a name="l00476"></a><span class="lineno">  476</span>&#160;          {</div>
<div class="line"><a name="l00477"></a><span class="lineno">  477</span>&#160;            TINFL_HUFF_DECODE(23, counter, &amp;r-&gt;m_tables[0]);</div>
<div class="line"><a name="l00478"></a><span class="lineno">  478</span>&#160;            <span class="keywordflow">if</span> (counter &gt;= 256)</div>
<div class="line"><a name="l00479"></a><span class="lineno">  479</span>&#160;              <span class="keywordflow">break</span>;</div>
<div class="line"><a name="l00480"></a><span class="lineno">  480</span>&#160;            <span class="keywordflow">while</span> (pOut_buf_cur &gt;= pOut_buf_end) { TINFL_CR_RETURN(24, TINFL_STATUS_HAS_MORE_OUTPUT); }</div>
<div class="line"><a name="l00481"></a><span class="lineno">  481</span>&#160;            *pOut_buf_cur++ = (mz_uint8)counter;</div>
<div class="line"><a name="l00482"></a><span class="lineno">  482</span>&#160;          }</div>
<div class="line"><a name="l00483"></a><span class="lineno">  483</span>&#160;          <span class="keywordflow">else</span></div>
<div class="line"><a name="l00484"></a><span class="lineno">  484</span>&#160;          {</div>
<div class="line"><a name="l00485"></a><span class="lineno">  485</span>&#160;            <span class="keywordtype">int</span> sym2; mz_uint code_len;</div>
<div class="line"><a name="l00486"></a><span class="lineno">  486</span>&#160;            <span class="keywordflow">if</span> (num_bits &lt; 30) { bit_buf |= (((mz_uint64)MZ_READ_LE32(pIn_buf_cur)) &lt;&lt; num_bits); pIn_buf_cur += 4; num_bits += 32; }</div>
<div class="line"><a name="l00487"></a><span class="lineno">  487</span>&#160;            <span class="keywordflow">if</span> ((sym2 = r-&gt;m_tables[0].m_look_up[bit_buf &amp; (TINFL_FAST_LOOKUP_SIZE - 1)]) &gt;= 0)</div>
<div class="line"><a name="l00488"></a><span class="lineno">  488</span>&#160;              code_len = sym2 &gt;&gt; 9;</div>
<div class="line"><a name="l00489"></a><span class="lineno">  489</span>&#160;            <span class="keywordflow">else</span></div>
<div class="line"><a name="l00490"></a><span class="lineno">  490</span>&#160;            {</div>
<div class="line"><a name="l00491"></a><span class="lineno">  491</span>&#160;              code_len = TINFL_FAST_LOOKUP_BITS; <span class="keywordflow">do</span> { sym2 = r-&gt;m_tables[0].m_tree[~sym2 + ((bit_buf &gt;&gt; code_len++) &amp; 1)]; } <span class="keywordflow">while</span> (sym2 &lt; 0);</div>
<div class="line"><a name="l00492"></a><span class="lineno">  492</span>&#160;            }</div>
<div class="line"><a name="l00493"></a><span class="lineno">  493</span>&#160;            counter = sym2; bit_buf &gt;&gt;= code_len; num_bits -= code_len;</div>
<div class="line"><a name="l00494"></a><span class="lineno">  494</span>&#160;            <span class="keywordflow">if</span> (counter &amp; 256)</div>
<div class="line"><a name="l00495"></a><span class="lineno">  495</span>&#160;              <span class="keywordflow">break</span>;</div>
<div class="line"><a name="l00496"></a><span class="lineno">  496</span>&#160;</div>
<div class="line"><a name="l00497"></a><span class="lineno">  497</span>&#160;            <span class="keywordflow">if</span> ((sym2 = r-&gt;m_tables[0].m_look_up[bit_buf &amp; (TINFL_FAST_LOOKUP_SIZE - 1)]) &gt;= 0)</div>
<div class="line"><a name="l00498"></a><span class="lineno">  498</span>&#160;              code_len = sym2 &gt;&gt; 9;</div>
<div class="line"><a name="l00499"></a><span class="lineno">  499</span>&#160;            <span class="keywordflow">else</span></div>
<div class="line"><a name="l00500"></a><span class="lineno">  500</span>&#160;            {</div>
<div class="line"><a name="l00501"></a><span class="lineno">  501</span>&#160;              code_len = TINFL_FAST_LOOKUP_BITS; <span class="keywordflow">do</span> { sym2 = r-&gt;m_tables[0].m_tree[~sym2 + ((bit_buf &gt;&gt; code_len++) &amp; 1)]; } <span class="keywordflow">while</span> (sym2 &lt; 0);</div>
<div class="line"><a name="l00502"></a><span class="lineno">  502</span>&#160;            }</div>
<div class="line"><a name="l00503"></a><span class="lineno">  503</span>&#160;            bit_buf &gt;&gt;= code_len; num_bits -= code_len;</div>
<div class="line"><a name="l00504"></a><span class="lineno">  504</span>&#160;</div>
<div class="line"><a name="l00505"></a><span class="lineno">  505</span>&#160;            pOut_buf_cur[0] = (mz_uint8)counter;</div>
<div class="line"><a name="l00506"></a><span class="lineno">  506</span>&#160;            <span class="keywordflow">if</span> (sym2 &amp; 256)</div>
<div class="line"><a name="l00507"></a><span class="lineno">  507</span>&#160;            {</div>
<div class="line"><a name="l00508"></a><span class="lineno">  508</span>&#160;              pOut_buf_cur++;</div>
<div class="line"><a name="l00509"></a><span class="lineno">  509</span>&#160;              counter = sym2;</div>
<div class="line"><a name="l00510"></a><span class="lineno">  510</span>&#160;              <span class="keywordflow">break</span>;</div>
<div class="line"><a name="l00511"></a><span class="lineno">  511</span>&#160;            }</div>
<div class="line"><a name="l00512"></a><span class="lineno">  512</span>&#160;            pOut_buf_cur[1] = (mz_uint8)sym2;</div>
<div class="line"><a name="l00513"></a><span class="lineno">  513</span>&#160;            pOut_buf_cur += 2;</div>
<div class="line"><a name="l00514"></a><span class="lineno">  514</span>&#160;          }</div>
<div class="line"><a name="l00515"></a><span class="lineno">  515</span>&#160;        }</div>
<div class="line"><a name="l00516"></a><span class="lineno">  516</span>&#160;        <span class="keywordflow">if</span> ((counter &amp;= 511) == 256) <span class="keywordflow">break</span>;</div>
<div class="line"><a name="l00517"></a><span class="lineno">  517</span>&#160;</div>
<div class="line"><a name="l00518"></a><span class="lineno">  518</span>&#160;        num_extra = s_length_extra[counter - 257]; counter = s_length_base[counter - 257];</div>
<div class="line"><a name="l00519"></a><span class="lineno">  519</span>&#160;        <span class="keywordflow">if</span> (num_extra) { mz_uint extra_bits; TINFL_GET_BITS(25, extra_bits, num_extra); counter += extra_bits; }</div>
<div class="line"><a name="l00520"></a><span class="lineno">  520</span>&#160;</div>
<div class="line"><a name="l00521"></a><span class="lineno">  521</span>&#160;        TINFL_HUFF_DECODE(26, dist, &amp;r-&gt;m_tables[1]);</div>
<div class="line"><a name="l00522"></a><span class="lineno">  522</span>&#160;        num_extra = s_dist_extra[dist]; dist = s_dist_base[dist];</div>
<div class="line"><a name="l00523"></a><span class="lineno">  523</span>&#160;        <span class="keywordflow">if</span> (num_extra) { mz_uint extra_bits; TINFL_GET_BITS(27, extra_bits, num_extra); dist += extra_bits; }</div>
<div class="line"><a name="l00524"></a><span class="lineno">  524</span>&#160;</div>
<div class="line"><a name="l00525"></a><span class="lineno">  525</span>&#160;        dist_from_out_buf_start = pOut_buf_cur - pOut_buf_start;</div>
<div class="line"><a name="l00526"></a><span class="lineno">  526</span>&#160;        <span class="keywordflow">if</span> ((dist &gt; dist_from_out_buf_start) &amp;&amp; (decomp_flags &amp; TINFL_FLAG_USING_NON_WRAPPING_OUTPUT_BUF))</div>
<div class="line"><a name="l00527"></a><span class="lineno">  527</span>&#160;        {</div>
<div class="line"><a name="l00528"></a><span class="lineno">  528</span>&#160;          TINFL_CR_RETURN_FOREVER(37, TINFL_STATUS_FAILED);</div>
<div class="line"><a name="l00529"></a><span class="lineno">  529</span>&#160;        }</div>
<div class="line"><a name="l00530"></a><span class="lineno">  530</span>&#160;</div>
<div class="line"><a name="l00531"></a><span class="lineno">  531</span>&#160;        pSrc = pOut_buf_start + ((dist_from_out_buf_start - dist) &amp; out_buf_size_mask);</div>
<div class="line"><a name="l00532"></a><span class="lineno">  532</span>&#160;</div>
<div class="line"><a name="l00533"></a><span class="lineno">  533</span>&#160;        <span class="keywordflow">if</span> ((MZ_MAX(pOut_buf_cur, pSrc) + counter) &gt; pOut_buf_end)</div>
<div class="line"><a name="l00534"></a><span class="lineno">  534</span>&#160;        {</div>
<div class="line"><a name="l00535"></a><span class="lineno">  535</span>&#160;          <span class="keywordflow">while</span> (counter--)</div>
<div class="line"><a name="l00536"></a><span class="lineno">  536</span>&#160;          {</div>
<div class="line"><a name="l00537"></a><span class="lineno">  537</span>&#160;            <span class="keywordflow">while</span> (pOut_buf_cur &gt;= pOut_buf_end) { TINFL_CR_RETURN(53, TINFL_STATUS_HAS_MORE_OUTPUT); }</div>
<div class="line"><a name="l00538"></a><span class="lineno">  538</span>&#160;            *pOut_buf_cur++ = pOut_buf_start[(dist_from_out_buf_start++ - dist) &amp; out_buf_size_mask];</div>
<div class="line"><a name="l00539"></a><span class="lineno">  539</span>&#160;          }</div>
<div class="line"><a name="l00540"></a><span class="lineno">  540</span>&#160;          <span class="keywordflow">continue</span>;</div>
<div class="line"><a name="l00541"></a><span class="lineno">  541</span>&#160;        }</div>
<div class="line"><a name="l00542"></a><span class="lineno">  542</span>&#160;        <span class="keywordflow">else</span> <span class="keywordflow">if</span> ((counter &gt;= 9) &amp;&amp; (counter &lt;= dist))</div>
<div class="line"><a name="l00543"></a><span class="lineno">  543</span>&#160;        {</div>
<div class="line"><a name="l00544"></a><span class="lineno">  544</span>&#160;          <span class="keyword">const</span> mz_uint8 *pSrc_end = pSrc + (counter &amp; ~7);</div>
<div class="line"><a name="l00545"></a><span class="lineno">  545</span>&#160;          <span class="keywordflow">do</span></div>
<div class="line"><a name="l00546"></a><span class="lineno">  546</span>&#160;          {</div>
<div class="line"><a name="l00547"></a><span class="lineno">  547</span>&#160;            ((mz_uint32 *)pOut_buf_cur)[0] = ((<span class="keyword">const</span> mz_uint32 *)pSrc)[0];</div>
<div class="line"><a name="l00548"></a><span class="lineno">  548</span>&#160;            ((mz_uint32 *)pOut_buf_cur)[1] = ((<span class="keyword">const</span> mz_uint32 *)pSrc)[1];</div>
<div class="line"><a name="l00549"></a><span class="lineno">  549</span>&#160;            pOut_buf_cur += 8;</div>
<div class="line"><a name="l00550"></a><span class="lineno">  550</span>&#160;          } <span class="keywordflow">while</span> ((pSrc += 8) &lt; pSrc_end);</div>
<div class="line"><a name="l00551"></a><span class="lineno">  551</span>&#160;          <span class="keywordflow">if</span> ((counter &amp;= 7) &lt; 3)</div>
<div class="line"><a name="l00552"></a><span class="lineno">  552</span>&#160;          {</div>
<div class="line"><a name="l00553"></a><span class="lineno">  553</span>&#160;            <span class="keywordflow">if</span> (counter)</div>
<div class="line"><a name="l00554"></a><span class="lineno">  554</span>&#160;            {</div>
<div class="line"><a name="l00555"></a><span class="lineno">  555</span>&#160;              pOut_buf_cur[0] = pSrc[0];</div>
<div class="line"><a name="l00556"></a><span class="lineno">  556</span>&#160;              <span class="keywordflow">if</span> (counter &gt; 1)</div>
<div class="line"><a name="l00557"></a><span class="lineno">  557</span>&#160;                pOut_buf_cur[1] = pSrc[1];</div>
<div class="line"><a name="l00558"></a><span class="lineno">  558</span>&#160;              pOut_buf_cur += counter;</div>
<div class="line"><a name="l00559"></a><span class="lineno">  559</span>&#160;            }</div>
<div class="line"><a name="l00560"></a><span class="lineno">  560</span>&#160;            <span class="keywordflow">continue</span>;</div>
<div class="line"><a name="l00561"></a><span class="lineno">  561</span>&#160;          }</div>
<div class="line"><a name="l00562"></a><span class="lineno">  562</span>&#160;        }</div>
<div class="line"><a name="l00563"></a><span class="lineno">  563</span>&#160;        <span class="keywordflow">do</span></div>
<div class="line"><a name="l00564"></a><span class="lineno">  564</span>&#160;        {</div>
<div class="line"><a name="l00565"></a><span class="lineno">  565</span>&#160;          pOut_buf_cur[0] = pSrc[0];</div>
<div class="line"><a name="l00566"></a><span class="lineno">  566</span>&#160;          pOut_buf_cur[1] = pSrc[1];</div>
<div class="line"><a name="l00567"></a><span class="lineno">  567</span>&#160;          pOut_buf_cur[2] = pSrc[2];</div>
<div class="line"><a name="l00568"></a><span class="lineno">  568</span>&#160;          pOut_buf_cur += 3; pSrc += 3;</div>
<div class="line"><a name="l00569"></a><span class="lineno">  569</span>&#160;        } <span class="keywordflow">while</span> ((<span class="keywordtype">int</span>)(counter -= 3) &gt; 2);</div>
<div class="line"><a name="l00570"></a><span class="lineno">  570</span>&#160;        <span class="keywordflow">if</span> ((<span class="keywordtype">int</span>)counter &gt; 0)</div>
<div class="line"><a name="l00571"></a><span class="lineno">  571</span>&#160;        {</div>
<div class="line"><a name="l00572"></a><span class="lineno">  572</span>&#160;          pOut_buf_cur[0] = pSrc[0];</div>
<div class="line"><a name="l00573"></a><span class="lineno">  573</span>&#160;          <span class="keywordflow">if</span> ((<span class="keywordtype">int</span>)counter &gt; 1)</div>
<div class="line"><a name="l00574"></a><span class="lineno">  574</span>&#160;            pOut_buf_cur[1] = pSrc[1];</div>
<div class="line"><a name="l00575"></a><span class="lineno">  575</span>&#160;          pOut_buf_cur += counter;</div>
<div class="line"><a name="l00576"></a><span class="lineno">  576</span>&#160;        }</div>
<div class="line"><a name="l00577"></a><span class="lineno">  577</span>&#160;      }</div>
<div class="line"><a name="l00578"></a><span class="lineno">  578</span>&#160;    }</div>
<div class="line"><a name="l00579"></a><span class="lineno">  579</span>&#160;  } <span class="keywordflow">while</span> (!(r-&gt;m_final &amp; 1));</div>
<div class="line"><a name="l00580"></a><span class="lineno">  580</span>&#160;  <span class="keywordflow">if</span> (decomp_flags &amp; TINFL_FLAG_PARSE_ZLIB_HEADER)</div>
<div class="line"><a name="l00581"></a><span class="lineno">  581</span>&#160;  {</div>
<div class="line"><a name="l00582"></a><span class="lineno">  582</span>&#160;    TINFL_SKIP_BITS(32, num_bits &amp; 7); <span class="keywordflow">for</span> (counter = 0; counter &lt; 4; ++counter) { mz_uint s; <span class="keywordflow">if</span> (num_bits) TINFL_GET_BITS(41, s, 8); <span class="keywordflow">else</span> TINFL_GET_BYTE(42, s); r-&gt;m_z_adler32 = (r-&gt;m_z_adler32 &lt;&lt; 8) | s; }</div>
<div class="line"><a name="l00583"></a><span class="lineno">  583</span>&#160;  }</div>
<div class="line"><a name="l00584"></a><span class="lineno">  584</span>&#160;  TINFL_CR_RETURN_FOREVER(34, TINFL_STATUS_DONE);</div>
<div class="line"><a name="l00585"></a><span class="lineno">  585</span>&#160;  TINFL_CR_FINISH</div>
<div class="line"><a name="l00586"></a><span class="lineno">  586</span>&#160;</div>
<div class="line"><a name="l00587"></a><span class="lineno">  587</span>&#160;common_exit:</div>
<div class="line"><a name="l00588"></a><span class="lineno">  588</span>&#160;  r-&gt;m_num_bits = num_bits; r-&gt;m_bit_buf = bit_buf; r-&gt;m_dist = dist; r-&gt;m_counter = counter; r-&gt;m_num_extra = num_extra; r-&gt;m_dist_from_out_buf_start = dist_from_out_buf_start;</div>
<div class="line"><a name="l00589"></a><span class="lineno">  589</span>&#160;  *pIn_buf_size = pIn_buf_cur - pIn_buf_next; *pOut_buf_size = pOut_buf_cur - pOut_buf_next;</div>
<div class="line"><a name="l00590"></a><span class="lineno">  590</span>&#160;  <span class="keywordflow">if</span> ((decomp_flags &amp; (TINFL_FLAG_PARSE_ZLIB_HEADER | TINFL_FLAG_COMPUTE_ADLER32)) &amp;&amp; (status &gt;= 0))</div>
<div class="line"><a name="l00591"></a><span class="lineno">  591</span>&#160;  {</div>
<div class="line"><a name="l00592"></a><span class="lineno">  592</span>&#160;    <span class="keyword">const</span> mz_uint8 *ptr = pOut_buf_next; <span class="keywordtype">size_t</span> buf_len = *pOut_buf_size;</div>
<div class="line"><a name="l00593"></a><span class="lineno">  593</span>&#160;    mz_uint32 i, s1 = r-&gt;m_check_adler32 &amp; 0xffff, s2 = r-&gt;m_check_adler32 &gt;&gt; 16; <span class="keywordtype">size_t</span> block_len = buf_len % 5552;</div>
<div class="line"><a name="l00594"></a><span class="lineno">  594</span>&#160;    <span class="keywordflow">while</span> (buf_len)</div>
<div class="line"><a name="l00595"></a><span class="lineno">  595</span>&#160;    {</div>
<div class="line"><a name="l00596"></a><span class="lineno">  596</span>&#160;      <span class="keywordflow">for</span> (i = 0; i + 7 &lt; block_len; i += 8, ptr += 8)</div>
<div class="line"><a name="l00597"></a><span class="lineno">  597</span>&#160;      {</div>
<div class="line"><a name="l00598"></a><span class="lineno">  598</span>&#160;        s1 += ptr[0], s2 += s1; s1 += ptr[1], s2 += s1; s1 += ptr[2], s2 += s1; s1 += ptr[3], s2 += s1;</div>
<div class="line"><a name="l00599"></a><span class="lineno">  599</span>&#160;        s1 += ptr[4], s2 += s1; s1 += ptr[5], s2 += s1; s1 += ptr[6], s2 += s1; s1 += ptr[7], s2 += s1;</div>
<div class="line"><a name="l00600"></a><span class="lineno">  600</span>&#160;      }</div>
<div class="line"><a name="l00601"></a><span class="lineno">  601</span>&#160;      <span class="keywordflow">for</span> ( ; i &lt; block_len; ++i) s1 += *ptr++, s2 += s1;</div>
<div class="line"><a name="l00602"></a><span class="lineno">  602</span>&#160;      s1 %= 65521U, s2 %= 65521U; buf_len -= block_len; block_len = 5552;</div>
<div class="line"><a name="l00603"></a><span class="lineno">  603</span>&#160;    }</div>
<div class="line"><a name="l00604"></a><span class="lineno">  604</span>&#160;    r-&gt;m_check_adler32 = (s2 &lt;&lt; 16) + s1; <span class="keywordflow">if</span> ((status == TINFL_STATUS_DONE) &amp;&amp; (decomp_flags &amp; TINFL_FLAG_PARSE_ZLIB_HEADER) &amp;&amp; (r-&gt;m_check_adler32 != r-&gt;m_z_adler32)) status = TINFL_STATUS_ADLER32_MISMATCH;</div>
<div class="line"><a name="l00605"></a><span class="lineno">  605</span>&#160;  }</div>
<div class="line"><a name="l00606"></a><span class="lineno">  606</span>&#160;  <span class="keywordflow">return</span> status;</div>
<div class="line"><a name="l00607"></a><span class="lineno">  607</span>&#160;}</div>
<div class="line"><a name="l00608"></a><span class="lineno">  608</span>&#160;</div>
<div class="line"><a name="l00609"></a><span class="lineno">  609</span>&#160;<span class="comment">// Higher level helper functions.</span></div>
<div class="line"><a name="l00610"></a><span class="lineno">  610</span>&#160;<span class="keywordtype">void</span> *tinfl_decompress_mem_to_heap(<span class="keyword">const</span> <span class="keywordtype">void</span> *pSrc_buf, <span class="keywordtype">size_t</span> src_buf_len, <span class="keywordtype">size_t</span> *pOut_len, <span class="keywordtype">int</span> flags)</div>
<div class="line"><a name="l00611"></a><span class="lineno">  611</span>&#160;{</div>
<div class="line"><a name="l00612"></a><span class="lineno">  612</span>&#160;  tinfl_decompressor decomp; <span class="keywordtype">void</span> *pBuf = NULL, *pNew_buf; <span class="keywordtype">size_t</span> src_buf_ofs = 0, out_buf_capacity = 0;</div>
<div class="line"><a name="l00613"></a><span class="lineno">  613</span>&#160;  *pOut_len = 0;</div>
<div class="line"><a name="l00614"></a><span class="lineno">  614</span>&#160;  tinfl_init(&amp;decomp);</div>
<div class="line"><a name="l00615"></a><span class="lineno">  615</span>&#160;  <span class="keywordflow">for</span> ( ; ; )</div>
<div class="line"><a name="l00616"></a><span class="lineno">  616</span>&#160;  {</div>
<div class="line"><a name="l00617"></a><span class="lineno">  617</span>&#160;    <span class="keywordtype">size_t</span> src_buf_size = src_buf_len - src_buf_ofs, dst_buf_size = out_buf_capacity - *pOut_len, new_out_buf_capacity;</div>
<div class="line"><a name="l00618"></a><span class="lineno">  618</span>&#160;    tinfl_status status = tinfl_decompress(&amp;decomp, (<span class="keyword">const</span> mz_uint8*)pSrc_buf + src_buf_ofs, &amp;src_buf_size, (mz_uint8*)pBuf, pBuf ? (mz_uint8*)pBuf + *pOut_len : NULL, &amp;dst_buf_size,</div>
<div class="line"><a name="l00619"></a><span class="lineno">  619</span>&#160;      (flags &amp; ~TINFL_FLAG_HAS_MORE_INPUT) | TINFL_FLAG_USING_NON_WRAPPING_OUTPUT_BUF);</div>
<div class="line"><a name="l00620"></a><span class="lineno">  620</span>&#160;    <span class="keywordflow">if</span> ((status &lt; 0) || (status == TINFL_STATUS_NEEDS_MORE_INPUT))</div>
<div class="line"><a name="l00621"></a><span class="lineno">  621</span>&#160;    {</div>
<div class="line"><a name="l00622"></a><span class="lineno">  622</span>&#160;      free(pBuf); *pOut_len = 0; <span class="keywordflow">return</span> NULL;</div>
<div class="line"><a name="l00623"></a><span class="lineno">  623</span>&#160;    }</div>
<div class="line"><a name="l00624"></a><span class="lineno">  624</span>&#160;    src_buf_ofs += src_buf_size;</div>
<div class="line"><a name="l00625"></a><span class="lineno">  625</span>&#160;    *pOut_len += dst_buf_size;</div>
<div class="line"><a name="l00626"></a><span class="lineno">  626</span>&#160;    <span class="keywordflow">if</span> (status == TINFL_STATUS_DONE) <span class="keywordflow">break</span>;</div>
<div class="line"><a name="l00627"></a><span class="lineno">  627</span>&#160;    new_out_buf_capacity = out_buf_capacity * 2; <span class="keywordflow">if</span> (new_out_buf_capacity &lt; 128) new_out_buf_capacity = 128;</div>
<div class="line"><a name="l00628"></a><span class="lineno">  628</span>&#160;    pNew_buf = realloc(pBuf, new_out_buf_capacity);</div>
<div class="line"><a name="l00629"></a><span class="lineno">  629</span>&#160;    <span class="keywordflow">if</span> (!pNew_buf)</div>
<div class="line"><a name="l00630"></a><span class="lineno">  630</span>&#160;    {</div>
<div class="line"><a name="l00631"></a><span class="lineno">  631</span>&#160;      free(pBuf); *pOut_len = 0; <span class="keywordflow">return</span> NULL;</div>
<div class="line"><a name="l00632"></a><span class="lineno">  632</span>&#160;    }</div>
<div class="line"><a name="l00633"></a><span class="lineno">  633</span>&#160;    pBuf = pNew_buf; out_buf_capacity = new_out_buf_capacity;</div>
<div class="line"><a name="l00634"></a><span class="lineno">  634</span>&#160;  }</div>
<div class="line"><a name="l00635"></a><span class="lineno">  635</span>&#160;  <span class="keywordflow">return</span> pBuf;</div>
<div class="line"><a name="l00636"></a><span class="lineno">  636</span>&#160;}</div>
<div class="line"><a name="l00637"></a><span class="lineno">  637</span>&#160;</div>
<div class="line"><a name="l00638"></a><span class="lineno">  638</span>&#160;<span class="keywordtype">size_t</span> tinfl_decompress_mem_to_mem(<span class="keywordtype">void</span> *pOut_buf, <span class="keywordtype">size_t</span> out_buf_len, <span class="keyword">const</span> <span class="keywordtype">void</span> *pSrc_buf, <span class="keywordtype">size_t</span> src_buf_len, <span class="keywordtype">int</span> flags)</div>
<div class="line"><a name="l00639"></a><span class="lineno">  639</span>&#160;{</div>
<div class="line"><a name="l00640"></a><span class="lineno">  640</span>&#160;  tinfl_decompressor decomp; tinfl_status status; tinfl_init(&amp;decomp);</div>
<div class="line"><a name="l00641"></a><span class="lineno">  641</span>&#160;  status = tinfl_decompress(&amp;decomp, (<span class="keyword">const</span> mz_uint8*)pSrc_buf, &amp;src_buf_len, (mz_uint8*)pOut_buf, (mz_uint8*)pOut_buf, &amp;out_buf_len, (flags &amp; ~TINFL_FLAG_HAS_MORE_INPUT) | TINFL_FLAG_USING_NON_WRAPPING_OUTPUT_BUF);</div>
<div class="line"><a name="l00642"></a><span class="lineno">  642</span>&#160;  <span class="keywordflow">return</span> (status != TINFL_STATUS_DONE) ? TINFL_DECOMPRESS_MEM_TO_MEM_FAILED : out_buf_len;</div>
<div class="line"><a name="l00643"></a><span class="lineno">  643</span>&#160;}</div>
<div class="line"><a name="l00644"></a><span class="lineno">  644</span>&#160;</div>
<div class="line"><a name="l00645"></a><span class="lineno">  645</span>&#160;<span class="keywordtype">int</span> tinfl_decompress_mem_to_callback(<span class="keyword">const</span> <span class="keywordtype">void</span> *pIn_buf, <span class="keywordtype">size_t</span> *pIn_buf_size, tinfl_put_buf_func_ptr pPut_buf_func, <span class="keywordtype">void</span> *pPut_buf_user, <span class="keywordtype">int</span> flags)</div>
<div class="line"><a name="l00646"></a><span class="lineno">  646</span>&#160;{</div>
<div class="line"><a name="l00647"></a><span class="lineno">  647</span>&#160;  <span class="keywordtype">int</span> result = 0;</div>
<div class="line"><a name="l00648"></a><span class="lineno">  648</span>&#160;  tinfl_decompressor decomp;</div>
<div class="line"><a name="l00649"></a><span class="lineno">  649</span>&#160;  mz_uint8 *pDict = (mz_uint8*)malloc(TINFL_LZ_DICT_SIZE); <span class="keywordtype">size_t</span> in_buf_ofs = 0, dict_ofs = 0;</div>
<div class="line"><a name="l00650"></a><span class="lineno">  650</span>&#160;  <span class="keywordflow">if</span> (!pDict)</div>
<div class="line"><a name="l00651"></a><span class="lineno">  651</span>&#160;    <span class="keywordflow">return</span> TINFL_STATUS_FAILED;</div>
<div class="line"><a name="l00652"></a><span class="lineno">  652</span>&#160;  tinfl_init(&amp;decomp);</div>
<div class="line"><a name="l00653"></a><span class="lineno">  653</span>&#160;  <span class="keywordflow">for</span> ( ; ; )</div>
<div class="line"><a name="l00654"></a><span class="lineno">  654</span>&#160;  {</div>
<div class="line"><a name="l00655"></a><span class="lineno">  655</span>&#160;    <span class="keywordtype">size_t</span> in_buf_size = *pIn_buf_size - in_buf_ofs, dst_buf_size = TINFL_LZ_DICT_SIZE - dict_ofs;</div>
<div class="line"><a name="l00656"></a><span class="lineno">  656</span>&#160;    tinfl_status status = tinfl_decompress(&amp;decomp, (<span class="keyword">const</span> mz_uint8*)pIn_buf + in_buf_ofs, &amp;in_buf_size, pDict, pDict + dict_ofs, &amp;dst_buf_size,</div>
<div class="line"><a name="l00657"></a><span class="lineno">  657</span>&#160;      (flags &amp; ~(TINFL_FLAG_HAS_MORE_INPUT | TINFL_FLAG_USING_NON_WRAPPING_OUTPUT_BUF)));</div>
<div class="line"><a name="l00658"></a><span class="lineno">  658</span>&#160;    in_buf_ofs += in_buf_size;</div>
<div class="line"><a name="l00659"></a><span class="lineno">  659</span>&#160;    <span class="keywordflow">if</span> ((dst_buf_size) &amp;&amp; (!(*pPut_buf_func)(pDict + dict_ofs, (<span class="keywordtype">int</span>)dst_buf_size, pPut_buf_user)))</div>
<div class="line"><a name="l00660"></a><span class="lineno">  660</span>&#160;      <span class="keywordflow">break</span>;</div>
<div class="line"><a name="l00661"></a><span class="lineno">  661</span>&#160;    <span class="keywordflow">if</span> (status != TINFL_STATUS_HAS_MORE_OUTPUT)</div>
<div class="line"><a name="l00662"></a><span class="lineno">  662</span>&#160;    {</div>
<div class="line"><a name="l00663"></a><span class="lineno">  663</span>&#160;      result = (status == TINFL_STATUS_DONE);</div>
<div class="line"><a name="l00664"></a><span class="lineno">  664</span>&#160;      <span class="keywordflow">break</span>;</div>
<div class="line"><a name="l00665"></a><span class="lineno">  665</span>&#160;    }</div>
<div class="line"><a name="l00666"></a><span class="lineno">  666</span>&#160;    dict_ofs = (dict_ofs + dst_buf_size) &amp; (TINFL_LZ_DICT_SIZE - 1);</div>
<div class="line"><a name="l00667"></a><span class="lineno">  667</span>&#160;  }</div>
<div class="line"><a name="l00668"></a><span class="lineno">  668</span>&#160;  free(pDict);</div>
<div class="line"><a name="l00669"></a><span class="lineno">  669</span>&#160;  *pIn_buf_size = in_buf_ofs;</div>
<div class="line"><a name="l00670"></a><span class="lineno">  670</span>&#160;  <span class="keywordflow">return</span> result;</div>
<div class="line"><a name="l00671"></a><span class="lineno">  671</span>&#160;}</div>
<div class="line"><a name="l00672"></a><span class="lineno">  672</span>&#160;</div>
<div class="line"><a name="l00673"></a><span class="lineno">  673</span>&#160;<span class="comment">// ------------------- Low-level Compression (independent from all decompression API&#39;s)</span></div>
<div class="line"><a name="l00674"></a><span class="lineno">  674</span>&#160;</div>
<div class="line"><a name="l00675"></a><span class="lineno">  675</span>&#160;<span class="comment">// Purposely making these tables static for faster init and thread safety.</span></div>
<div class="line"><a name="l00676"></a><span class="lineno">  676</span>&#160;<span class="keyword">static</span> <span class="keyword">const</span> mz_uint16 s_tdefl_len_sym[256] = {</div>
<div class="line"><a name="l00677"></a><span class="lineno">  677</span>&#160;  257,258,259,260,261,262,263,264,265,265,266,266,267,267,268,268,269,269,269,269,270,270,270,270,271,271,271,271,272,272,272,272,</div>
<div class="line"><a name="l00678"></a><span class="lineno">  678</span>&#160;  273,273,273,273,273,273,273,273,274,274,274,274,274,274,274,274,275,275,275,275,275,275,275,275,276,276,276,276,276,276,276,276,</div>
<div class="line"><a name="l00679"></a><span class="lineno">  679</span>&#160;  277,277,277,277,277,277,277,277,277,277,277,277,277,277,277,277,278,278,278,278,278,278,278,278,278,278,278,278,278,278,278,278,</div>
<div class="line"><a name="l00680"></a><span class="lineno">  680</span>&#160;  279,279,279,279,279,279,279,279,279,279,279,279,279,279,279,279,280,280,280,280,280,280,280,280,280,280,280,280,280,280,280,280,</div>
<div class="line"><a name="l00681"></a><span class="lineno">  681</span>&#160;  281,281,281,281,281,281,281,281,281,281,281,281,281,281,281,281,281,281,281,281,281,281,281,281,281,281,281,281,281,281,281,281,</div>
<div class="line"><a name="l00682"></a><span class="lineno">  682</span>&#160;  282,282,282,282,282,282,282,282,282,282,282,282,282,282,282,282,282,282,282,282,282,282,282,282,282,282,282,282,282,282,282,282,</div>
<div class="line"><a name="l00683"></a><span class="lineno">  683</span>&#160;  283,283,283,283,283,283,283,283,283,283,283,283,283,283,283,283,283,283,283,283,283,283,283,283,283,283,283,283,283,283,283,283,</div>
<div class="line"><a name="l00684"></a><span class="lineno">  684</span>&#160;  284,284,284,284,284,284,284,284,284,284,284,284,284,284,284,284,284,284,284,284,284,284,284,284,284,284,284,284,284,284,284,285 };</div>
<div class="line"><a name="l00685"></a><span class="lineno">  685</span>&#160;</div>
<div class="line"><a name="l00686"></a><span class="lineno">  686</span>&#160;<span class="keyword">static</span> <span class="keyword">const</span> mz_uint8 s_tdefl_len_extra[256] = {</div>
<div class="line"><a name="l00687"></a><span class="lineno">  687</span>&#160;  0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,</div>
<div class="line"><a name="l00688"></a><span class="lineno">  688</span>&#160;  4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,</div>
<div class="line"><a name="l00689"></a><span class="lineno">  689</span>&#160;  5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,</div>
<div class="line"><a name="l00690"></a><span class="lineno">  690</span>&#160;  5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,0 };</div>
<div class="line"><a name="l00691"></a><span class="lineno">  691</span>&#160;</div>
<div class="line"><a name="l00692"></a><span class="lineno">  692</span>&#160;<span class="keyword">static</span> <span class="keyword">const</span> mz_uint8 s_tdefl_small_dist_sym[512] = {</div>
<div class="line"><a name="l00693"></a><span class="lineno">  693</span>&#160;  0,1,2,3,4,4,5,5,6,6,6,6,7,7,7,7,8,8,8,8,8,8,8,8,9,9,9,9,9,9,9,9,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,11,11,11,11,11,11,</div>
<div class="line"><a name="l00694"></a><span class="lineno">  694</span>&#160;  11,11,11,11,11,11,11,11,11,11,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,13,</div>
<div class="line"><a name="l00695"></a><span class="lineno">  695</span>&#160;  13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,14,14,14,14,14,14,14,14,14,14,14,14,</div>
<div class="line"><a name="l00696"></a><span class="lineno">  696</span>&#160;  14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,</div>
<div class="line"><a name="l00697"></a><span class="lineno">  697</span>&#160;  14,14,14,14,14,14,14,14,14,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,</div>
<div class="line"><a name="l00698"></a><span class="lineno">  698</span>&#160;  15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,16,16,16,16,16,16,16,16,16,16,16,16,16,</div>
<div class="line"><a name="l00699"></a><span class="lineno">  699</span>&#160;  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,</div>
<div class="line"><a name="l00700"></a><span class="lineno">  700</span>&#160;  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,</div>
<div class="line"><a name="l00701"></a><span class="lineno">  701</span>&#160;  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,17,17,17,17,17,17,17,17,17,17,17,17,17,17,</div>
<div class="line"><a name="l00702"></a><span class="lineno">  702</span>&#160;  17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,</div>
<div class="line"><a name="l00703"></a><span class="lineno">  703</span>&#160;  17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,</div>
<div class="line"><a name="l00704"></a><span class="lineno">  704</span>&#160;  17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17 };</div>
<div class="line"><a name="l00705"></a><span class="lineno">  705</span>&#160;</div>
<div class="line"><a name="l00706"></a><span class="lineno">  706</span>&#160;<span class="keyword">static</span> <span class="keyword">const</span> mz_uint8 s_tdefl_small_dist_extra[512] = {</div>
<div class="line"><a name="l00707"></a><span class="lineno">  707</span>&#160;  0,0,0,0,1,1,1,1,2,2,2,2,2,2,2,2,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,5,5,5,5,5,5,5,5,</div>
<div class="line"><a name="l00708"></a><span class="lineno">  708</span>&#160;  5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,</div>
<div class="line"><a name="l00709"></a><span class="lineno">  709</span>&#160;  6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,</div>
<div class="line"><a name="l00710"></a><span class="lineno">  710</span>&#160;  6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,</div>
<div class="line"><a name="l00711"></a><span class="lineno">  711</span>&#160;  7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,</div>
<div class="line"><a name="l00712"></a><span class="lineno">  712</span>&#160;  7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,</div>
<div class="line"><a name="l00713"></a><span class="lineno">  713</span>&#160;  7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,</div>
<div class="line"><a name="l00714"></a><span class="lineno">  714</span>&#160;  7,7,7,7,7,7,7,7 };</div>
<div class="line"><a name="l00715"></a><span class="lineno">  715</span>&#160;</div>
<div class="line"><a name="l00716"></a><span class="lineno">  716</span>&#160;<span class="keyword">static</span> <span class="keyword">const</span> mz_uint8 s_tdefl_large_dist_sym[128] = {</div>
<div class="line"><a name="l00717"></a><span class="lineno">  717</span>&#160;  0,0,18,19,20,20,21,21,22,22,22,22,23,23,23,23,24,24,24,24,24,24,24,24,25,25,25,25,25,25,25,25,26,26,26,26,26,26,26,26,26,26,26,26,</div>
<div class="line"><a name="l00718"></a><span class="lineno">  718</span>&#160;  26,26,26,26,27,27,27,27,27,27,27,27,27,27,27,27,27,27,27,27,28,28,28,28,28,28,28,28,28,28,28,28,28,28,28,28,28,28,28,28,28,28,28,28,</div>
<div class="line"><a name="l00719"></a><span class="lineno">  719</span>&#160;  28,28,28,28,28,28,28,28,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29 };</div>
<div class="line"><a name="l00720"></a><span class="lineno">  720</span>&#160;</div>
<div class="line"><a name="l00721"></a><span class="lineno">  721</span>&#160;<span class="keyword">static</span> <span class="keyword">const</span> mz_uint8 s_tdefl_large_dist_extra[128] = {</div>
<div class="line"><a name="l00722"></a><span class="lineno">  722</span>&#160;  0,0,8,8,9,9,9,9,10,10,10,10,10,10,10,10,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,</div>
<div class="line"><a name="l00723"></a><span class="lineno">  723</span>&#160;  12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,</div>
<div class="line"><a name="l00724"></a><span class="lineno">  724</span>&#160;  13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13 };</div>
<div class="line"><a name="l00725"></a><span class="lineno">  725</span>&#160;</div>
<div class="line"><a name="l00726"></a><span class="lineno">  726</span>&#160;<span class="comment">// Radix sorts tdefl_sym_freq[] array by 16-bit key m_key. Returns ptr to sorted values.</span></div>
<div class="line"><a name="l00727"></a><span class="lineno">  727</span>&#160;<span class="keyword">typedef</span> <span class="keyword">struct </span>{ mz_uint16 m_key, m_sym_index; } tdefl_sym_freq;</div>
<div class="line"><a name="l00728"></a><span class="lineno">  728</span>&#160;<span class="keyword">static</span> tdefl_sym_freq* tdefl_radix_sort_syms(mz_uint num_syms, tdefl_sym_freq* pSyms0, tdefl_sym_freq* pSyms1)</div>
<div class="line"><a name="l00729"></a><span class="lineno">  729</span>&#160;{</div>
<div class="line"><a name="l00730"></a><span class="lineno">  730</span>&#160;  mz_uint32 total_passes = 2, pass_shift, pass, i, hist[256 * 2]; tdefl_sym_freq* pCur_syms = pSyms0, *pNew_syms = pSyms1; MZ_CLEAR_OBJ(hist);</div>
<div class="line"><a name="l00731"></a><span class="lineno">  731</span>&#160;  <span class="keywordflow">for</span> (i = 0; i &lt; num_syms; i++) { mz_uint freq = pSyms0[i].m_key; hist[freq &amp; 0xFF]++; hist[256 + ((freq &gt;&gt; 8) &amp; 0xFF)]++; }</div>
<div class="line"><a name="l00732"></a><span class="lineno">  732</span>&#160;  <span class="keywordflow">while</span> ((total_passes &gt; 1) &amp;&amp; (num_syms == hist[(total_passes - 1) * 256])) total_passes--;</div>
<div class="line"><a name="l00733"></a><span class="lineno">  733</span>&#160;  <span class="keywordflow">for</span> (pass_shift = 0, pass = 0; pass &lt; total_passes; pass++, pass_shift += 8)</div>
<div class="line"><a name="l00734"></a><span class="lineno">  734</span>&#160;  {</div>
<div class="line"><a name="l00735"></a><span class="lineno">  735</span>&#160;    <span class="keyword">const</span> mz_uint32* pHist = &amp;hist[pass &lt;&lt; 8];</div>
<div class="line"><a name="l00736"></a><span class="lineno">  736</span>&#160;    mz_uint offsets[256], cur_ofs = 0;</div>
<div class="line"><a name="l00737"></a><span class="lineno">  737</span>&#160;    <span class="keywordflow">for</span> (i = 0; i &lt; 256; i++) { offsets[i] = cur_ofs; cur_ofs += pHist[i]; }</div>
<div class="line"><a name="l00738"></a><span class="lineno">  738</span>&#160;    <span class="keywordflow">for</span> (i = 0; i &lt; num_syms; i++) pNew_syms[offsets[(pCur_syms[i].m_key &gt;&gt; pass_shift) &amp; 0xFF]++] = pCur_syms[i];</div>
<div class="line"><a name="l00739"></a><span class="lineno">  739</span>&#160;    { tdefl_sym_freq* t = pCur_syms; pCur_syms = pNew_syms; pNew_syms = t; }</div>
<div class="line"><a name="l00740"></a><span class="lineno">  740</span>&#160;  }</div>
<div class="line"><a name="l00741"></a><span class="lineno">  741</span>&#160;  <span class="keywordflow">return</span> pCur_syms;</div>
<div class="line"><a name="l00742"></a><span class="lineno">  742</span>&#160;}</div>
<div class="line"><a name="l00743"></a><span class="lineno">  743</span>&#160;</div>
<div class="line"><a name="l00744"></a><span class="lineno">  744</span>&#160;<span class="comment">// tdefl_calculate_minimum_redundancy() originally written by: Alistair Moffat, alistair@cs.mu.oz.au, Jyrki Katajainen, jyrki@diku.dk, November 1996.</span></div>
<div class="line"><a name="l00745"></a><span class="lineno">  745</span>&#160;<span class="keyword">static</span> <span class="keywordtype">void</span> tdefl_calculate_minimum_redundancy(tdefl_sym_freq *A, <span class="keywordtype">int</span> n)</div>
<div class="line"><a name="l00746"></a><span class="lineno">  746</span>&#160;{</div>
<div class="line"><a name="l00747"></a><span class="lineno">  747</span>&#160;  <span class="keywordtype">int</span> <a class="code" href="file_8h.html#a58a3a30b85a63ddc4b74c15de58fa682">root</a>, leaf, next, avbl, used, dpth;</div>
<div class="line"><a name="l00748"></a><span class="lineno">  748</span>&#160;  <span class="keywordflow">if</span> (n==0) <span class="keywordflow">return</span>; <span class="keywordflow">else</span> <span class="keywordflow">if</span> (n==1) { A[0].m_key = 1; <span class="keywordflow">return</span>; }</div>
<div class="line"><a name="l00749"></a><span class="lineno">  749</span>&#160;  A[0].m_key += A[1].m_key; root = 0; leaf = 2;</div>
<div class="line"><a name="l00750"></a><span class="lineno">  750</span>&#160;  <span class="keywordflow">for</span> (next=1; next &lt; n-1; next++)</div>
<div class="line"><a name="l00751"></a><span class="lineno">  751</span>&#160;  {</div>
<div class="line"><a name="l00752"></a><span class="lineno">  752</span>&#160;    <span class="keywordflow">if</span> (leaf&gt;=n || A[root].m_key&lt;A[leaf].m_key) { A[next].m_key = A[<a class="code" href="file_8h.html#a58a3a30b85a63ddc4b74c15de58fa682">root</a>].m_key; A[root++].m_key = (mz_uint16)next; } <span class="keywordflow">else</span> A[next].m_key = A[leaf++].m_key;</div>
<div class="line"><a name="l00753"></a><span class="lineno">  753</span>&#160;    <span class="keywordflow">if</span> (leaf&gt;=n || (root&lt;next &amp;&amp; A[root].m_key&lt;A[leaf].m_key)) { A[next].m_key = (mz_uint16)(A[next].m_key + A[root].m_key); A[root++].m_key = (mz_uint16)next; } <span class="keywordflow">else</span> A[next].m_key = (mz_uint16)(A[next].m_key + A[leaf++].m_key);</div>
<div class="line"><a name="l00754"></a><span class="lineno">  754</span>&#160;  }</div>
<div class="line"><a name="l00755"></a><span class="lineno">  755</span>&#160;  A[n-2].m_key = 0; <span class="keywordflow">for</span> (next=n-3; next&gt;=0; next--) A[next].m_key = A[A[next].m_key].m_key+1;</div>
<div class="line"><a name="l00756"></a><span class="lineno">  756</span>&#160;  avbl = 1; used = dpth = 0; root = n-2; next = n-1;</div>
<div class="line"><a name="l00757"></a><span class="lineno">  757</span>&#160;  <span class="keywordflow">while</span> (avbl&gt;0)</div>
<div class="line"><a name="l00758"></a><span class="lineno">  758</span>&#160;  {</div>
<div class="line"><a name="l00759"></a><span class="lineno">  759</span>&#160;    <span class="keywordflow">while</span> (root&gt;=0 &amp;&amp; (<span class="keywordtype">int</span>)A[<a class="code" href="file_8h.html#a58a3a30b85a63ddc4b74c15de58fa682">root</a>].m_key==dpth) { used++; root--; }</div>
<div class="line"><a name="l00760"></a><span class="lineno">  760</span>&#160;    <span class="keywordflow">while</span> (avbl&gt;used) { A[next--].m_key = (mz_uint16)(dpth); avbl--; }</div>
<div class="line"><a name="l00761"></a><span class="lineno">  761</span>&#160;    avbl = 2*used; dpth++; used = 0;</div>
<div class="line"><a name="l00762"></a><span class="lineno">  762</span>&#160;  }</div>
<div class="line"><a name="l00763"></a><span class="lineno">  763</span>&#160;}</div>
<div class="line"><a name="l00764"></a><span class="lineno">  764</span>&#160;</div>
<div class="line"><a name="l00765"></a><span class="lineno">  765</span>&#160;<span class="comment">// Limits canonical Huffman code table&#39;s max code size.</span></div>
<div class="line"><a name="l00766"></a><span class="lineno">  766</span>&#160;<span class="keyword">enum</span> { TDEFL_MAX_SUPPORTED_HUFF_CODESIZE = 32 };</div>
<div class="line"><a name="l00767"></a><span class="lineno">  767</span>&#160;<span class="keyword">static</span> <span class="keywordtype">void</span> tdefl_huffman_enforce_max_code_size(<span class="keywordtype">int</span> *pNum_codes, <span class="keywordtype">int</span> code_list_len, <span class="keywordtype">int</span> max_code_size)</div>
<div class="line"><a name="l00768"></a><span class="lineno">  768</span>&#160;{</div>
<div class="line"><a name="l00769"></a><span class="lineno">  769</span>&#160;  <span class="keywordtype">int</span> i; mz_uint32 total = 0; <span class="keywordflow">if</span> (code_list_len &lt;= 1) <span class="keywordflow">return</span>;</div>
<div class="line"><a name="l00770"></a><span class="lineno">  770</span>&#160;  <span class="keywordflow">for</span> (i = max_code_size + 1; i &lt;= TDEFL_MAX_SUPPORTED_HUFF_CODESIZE; i++) pNum_codes[max_code_size] += pNum_codes[i];</div>
<div class="line"><a name="l00771"></a><span class="lineno">  771</span>&#160;  <span class="keywordflow">for</span> (i = max_code_size; i &gt; 0; i--) total += (((mz_uint32)pNum_codes[i]) &lt;&lt; (max_code_size - i));</div>
<div class="line"><a name="l00772"></a><span class="lineno">  772</span>&#160;  <span class="keywordflow">while</span> (total != (1UL &lt;&lt; max_code_size))</div>
<div class="line"><a name="l00773"></a><span class="lineno">  773</span>&#160;  {</div>
<div class="line"><a name="l00774"></a><span class="lineno">  774</span>&#160;    pNum_codes[max_code_size]--;</div>
<div class="line"><a name="l00775"></a><span class="lineno">  775</span>&#160;    <span class="keywordflow">for</span> (i = max_code_size - 1; i &gt; 0; i--) <span class="keywordflow">if</span> (pNum_codes[i]) { pNum_codes[i]--; pNum_codes[i + 1] += 2; <span class="keywordflow">break</span>; }</div>
<div class="line"><a name="l00776"></a><span class="lineno">  776</span>&#160;    total--;</div>
<div class="line"><a name="l00777"></a><span class="lineno">  777</span>&#160;  }</div>
<div class="line"><a name="l00778"></a><span class="lineno">  778</span>&#160;}</div>
<div class="line"><a name="l00779"></a><span class="lineno">  779</span>&#160;</div>
<div class="line"><a name="l00780"></a><span class="lineno">  780</span>&#160;<span class="keyword">static</span> <span class="keywordtype">void</span> tdefl_optimize_huffman_table(tdefl_compressor *d, <span class="keywordtype">int</span> table_num, <span class="keywordtype">int</span> table_len, <span class="keywordtype">int</span> code_size_limit, <span class="keywordtype">int</span> static_table)</div>
<div class="line"><a name="l00781"></a><span class="lineno">  781</span>&#160;{</div>
<div class="line"><a name="l00782"></a><span class="lineno">  782</span>&#160;  <span class="keywordtype">int</span> i, j, l, num_codes[1 + TDEFL_MAX_SUPPORTED_HUFF_CODESIZE]; mz_uint next_code[TDEFL_MAX_SUPPORTED_HUFF_CODESIZE + 1]; MZ_CLEAR_OBJ(num_codes);</div>
<div class="line"><a name="l00783"></a><span class="lineno">  783</span>&#160;  <span class="keywordflow">if</span> (static_table)</div>
<div class="line"><a name="l00784"></a><span class="lineno">  784</span>&#160;  {</div>
<div class="line"><a name="l00785"></a><span class="lineno">  785</span>&#160;    <span class="keywordflow">for</span> (i = 0; i &lt; table_len; i++) num_codes[d-&gt;m_huff_code_sizes[table_num][i]]++;</div>
<div class="line"><a name="l00786"></a><span class="lineno">  786</span>&#160;  }</div>
<div class="line"><a name="l00787"></a><span class="lineno">  787</span>&#160;  <span class="keywordflow">else</span></div>
<div class="line"><a name="l00788"></a><span class="lineno">  788</span>&#160;  {</div>
<div class="line"><a name="l00789"></a><span class="lineno">  789</span>&#160;    tdefl_sym_freq syms0[TDEFL_MAX_HUFF_SYMBOLS], syms1[TDEFL_MAX_HUFF_SYMBOLS], *pSyms;</div>
<div class="line"><a name="l00790"></a><span class="lineno">  790</span>&#160;    <span class="keywordtype">int</span> num_used_syms = 0;</div>
<div class="line"><a name="l00791"></a><span class="lineno">  791</span>&#160;    <span class="keyword">const</span> mz_uint16 *pSym_count = &amp;d-&gt;m_huff_count[table_num][0];</div>
<div class="line"><a name="l00792"></a><span class="lineno">  792</span>&#160;    <span class="keywordflow">for</span> (i = 0; i &lt; table_len; i++) <span class="keywordflow">if</span> (pSym_count[i]) { syms0[num_used_syms].m_key = (mz_uint16)pSym_count[i]; syms0[num_used_syms++].m_sym_index = (mz_uint16)i; }</div>
<div class="line"><a name="l00793"></a><span class="lineno">  793</span>&#160;</div>
<div class="line"><a name="l00794"></a><span class="lineno">  794</span>&#160;    pSyms = tdefl_radix_sort_syms(num_used_syms, syms0, syms1); tdefl_calculate_minimum_redundancy(pSyms, num_used_syms);</div>
<div class="line"><a name="l00795"></a><span class="lineno">  795</span>&#160;</div>
<div class="line"><a name="l00796"></a><span class="lineno">  796</span>&#160;    <span class="keywordflow">for</span> (i = 0; i &lt; num_used_syms; i++) num_codes[pSyms[i].m_key]++;</div>
<div class="line"><a name="l00797"></a><span class="lineno">  797</span>&#160;</div>
<div class="line"><a name="l00798"></a><span class="lineno">  798</span>&#160;    tdefl_huffman_enforce_max_code_size(num_codes, num_used_syms, code_size_limit);</div>
<div class="line"><a name="l00799"></a><span class="lineno">  799</span>&#160;</div>
<div class="line"><a name="l00800"></a><span class="lineno">  800</span>&#160;    MZ_CLEAR_OBJ(d-&gt;m_huff_code_sizes[table_num]); MZ_CLEAR_OBJ(d-&gt;m_huff_codes[table_num]);</div>
<div class="line"><a name="l00801"></a><span class="lineno">  801</span>&#160;    <span class="keywordflow">for</span> (i = 1, j = num_used_syms; i &lt;= code_size_limit; i++)</div>
<div class="line"><a name="l00802"></a><span class="lineno">  802</span>&#160;      <span class="keywordflow">for</span> (l = num_codes[i]; l &gt; 0; l--) d-&gt;m_huff_code_sizes[table_num][pSyms[--j].m_sym_index] = (mz_uint8)(i);</div>
<div class="line"><a name="l00803"></a><span class="lineno">  803</span>&#160;  }</div>
<div class="line"><a name="l00804"></a><span class="lineno">  804</span>&#160;</div>
<div class="line"><a name="l00805"></a><span class="lineno">  805</span>&#160;  next_code[1] = 0; <span class="keywordflow">for</span> (j = 0, i = 2; i &lt;= code_size_limit; i++) next_code[i] = j = ((j + num_codes[i - 1]) &lt;&lt; 1);</div>
<div class="line"><a name="l00806"></a><span class="lineno">  806</span>&#160;</div>
<div class="line"><a name="l00807"></a><span class="lineno">  807</span>&#160;  <span class="keywordflow">for</span> (i = 0; i &lt; table_len; i++)</div>
<div class="line"><a name="l00808"></a><span class="lineno">  808</span>&#160;  {</div>
<div class="line"><a name="l00809"></a><span class="lineno">  809</span>&#160;    mz_uint rev_code = 0, code, code_size; <span class="keywordflow">if</span> ((code_size = d-&gt;m_huff_code_sizes[table_num][i]) == 0) <span class="keywordflow">continue</span>;</div>
<div class="line"><a name="l00810"></a><span class="lineno">  810</span>&#160;    code = next_code[code_size]++; <span class="keywordflow">for</span> (l = code_size; l &gt; 0; l--, code &gt;&gt;= 1) rev_code = (rev_code &lt;&lt; 1) | (code &amp; 1);</div>
<div class="line"><a name="l00811"></a><span class="lineno">  811</span>&#160;    d-&gt;m_huff_codes[table_num][i] = (mz_uint16)rev_code;</div>
<div class="line"><a name="l00812"></a><span class="lineno">  812</span>&#160;  }</div>
<div class="line"><a name="l00813"></a><span class="lineno">  813</span>&#160;}</div>
<div class="line"><a name="l00814"></a><span class="lineno">  814</span>&#160;</div>
<div class="line"><a name="l00815"></a><span class="lineno">  815</span>&#160;<span class="preprocessor">#define TDEFL_PUT_BITS(b, l) do { \</span></div>
<div class="line"><a name="l00816"></a><span class="lineno">  816</span>&#160;<span class="preprocessor">  mz_uint bits = b; mz_uint len = l; assert(bits &lt;= ((1U &lt;&lt; len) - 1U)); \</span></div>
<div class="line"><a name="l00817"></a><span class="lineno">  817</span>&#160;<span class="preprocessor">  d-&gt;m_bit_buffer |= (bits &lt;&lt; d-&gt;m_bits_in); d-&gt;m_bits_in += len; \</span></div>
<div class="line"><a name="l00818"></a><span class="lineno">  818</span>&#160;<span class="preprocessor">  while (d-&gt;m_bits_in &gt;= 8) { \</span></div>
<div class="line"><a name="l00819"></a><span class="lineno">  819</span>&#160;<span class="preprocessor">    if (d-&gt;m_pOutput_buf &lt; d-&gt;m_pOutput_buf_end) \</span></div>
<div class="line"><a name="l00820"></a><span class="lineno">  820</span>&#160;<span class="preprocessor">      *d-&gt;m_pOutput_buf++ = (mz_uint8)(d-&gt;m_bit_buffer); \</span></div>
<div class="line"><a name="l00821"></a><span class="lineno">  821</span>&#160;<span class="preprocessor">      d-&gt;m_bit_buffer &gt;&gt;= 8; \</span></div>
<div class="line"><a name="l00822"></a><span class="lineno">  822</span>&#160;<span class="preprocessor">      d-&gt;m_bits_in -= 8; \</span></div>
<div class="line"><a name="l00823"></a><span class="lineno">  823</span>&#160;<span class="preprocessor">  } \</span></div>
<div class="line"><a name="l00824"></a><span class="lineno">  824</span>&#160;<span class="preprocessor">} MZ_MACRO_END</span></div>
<div class="line"><a name="l00825"></a><span class="lineno">  825</span>&#160;<span class="preprocessor"></span></div>
<div class="line"><a name="l00826"></a><span class="lineno">  826</span>&#160;<span class="preprocessor">#define TDEFL_RLE_PREV_CODE_SIZE() { if (rle_repeat_count) { \</span></div>
<div class="line"><a name="l00827"></a><span class="lineno">  827</span>&#160;<span class="preprocessor">  if (rle_repeat_count &lt; 3) { \</span></div>
<div class="line"><a name="l00828"></a><span class="lineno">  828</span>&#160;<span class="preprocessor">    d-&gt;m_huff_count[2][prev_code_size] = (mz_uint16)(d-&gt;m_huff_count[2][prev_code_size] + rle_repeat_count); \</span></div>
<div class="line"><a name="l00829"></a><span class="lineno">  829</span>&#160;<span class="preprocessor">    while (rle_repeat_count--) packed_code_sizes[num_packed_code_sizes++] = prev_code_size; \</span></div>
<div class="line"><a name="l00830"></a><span class="lineno">  830</span>&#160;<span class="preprocessor">  } else { \</span></div>
<div class="line"><a name="l00831"></a><span class="lineno">  831</span>&#160;<span class="preprocessor">    d-&gt;m_huff_count[2][16] = (mz_uint16)(d-&gt;m_huff_count[2][16] + 1); packed_code_sizes[num_packed_code_sizes++] = 16; packed_code_sizes[num_packed_code_sizes++] = (mz_uint8)(rle_repeat_count - 3); \</span></div>
<div class="line"><a name="l00832"></a><span class="lineno">  832</span>&#160;<span class="preprocessor">} rle_repeat_count = 0; } }</span></div>
<div class="line"><a name="l00833"></a><span class="lineno">  833</span>&#160;<span class="preprocessor"></span></div>
<div class="line"><a name="l00834"></a><span class="lineno">  834</span>&#160;<span class="preprocessor">#define TDEFL_RLE_ZERO_CODE_SIZE() { if (rle_z_count) { \</span></div>
<div class="line"><a name="l00835"></a><span class="lineno">  835</span>&#160;<span class="preprocessor">  if (rle_z_count &lt; 3) { \</span></div>
<div class="line"><a name="l00836"></a><span class="lineno">  836</span>&#160;<span class="preprocessor">    d-&gt;m_huff_count[2][0] = (mz_uint16)(d-&gt;m_huff_count[2][0] + rle_z_count); while (rle_z_count--) packed_code_sizes[num_packed_code_sizes++] = 0; \</span></div>
<div class="line"><a name="l00837"></a><span class="lineno">  837</span>&#160;<span class="preprocessor">  } else if (rle_z_count &lt;= 10) { \</span></div>
<div class="line"><a name="l00838"></a><span class="lineno">  838</span>&#160;<span class="preprocessor">    d-&gt;m_huff_count[2][17] = (mz_uint16)(d-&gt;m_huff_count[2][17] + 1); packed_code_sizes[num_packed_code_sizes++] = 17; packed_code_sizes[num_packed_code_sizes++] = (mz_uint8)(rle_z_count - 3); \</span></div>
<div class="line"><a name="l00839"></a><span class="lineno">  839</span>&#160;<span class="preprocessor">  } else { \</span></div>
<div class="line"><a name="l00840"></a><span class="lineno">  840</span>&#160;<span class="preprocessor">    d-&gt;m_huff_count[2][18] = (mz_uint16)(d-&gt;m_huff_count[2][18] + 1); packed_code_sizes[num_packed_code_sizes++] = 18; packed_code_sizes[num_packed_code_sizes++] = (mz_uint8)(rle_z_count - 11); \</span></div>
<div class="line"><a name="l00841"></a><span class="lineno">  841</span>&#160;<span class="preprocessor">} rle_z_count = 0; } }</span></div>
<div class="line"><a name="l00842"></a><span class="lineno">  842</span>&#160;<span class="preprocessor"></span></div>
<div class="line"><a name="l00843"></a><span class="lineno">  843</span>&#160;<span class="keyword">static</span> mz_uint8 s_tdefl_packed_code_size_syms_swizzle[] = { 16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15 };</div>
<div class="line"><a name="l00844"></a><span class="lineno">  844</span>&#160;</div>
<div class="line"><a name="l00845"></a><span class="lineno">  845</span>&#160;<span class="keyword">static</span> <span class="keywordtype">void</span> tdefl_start_dynamic_block(tdefl_compressor *d)</div>
<div class="line"><a name="l00846"></a><span class="lineno">  846</span>&#160;{</div>
<div class="line"><a name="l00847"></a><span class="lineno">  847</span>&#160;  <span class="keywordtype">int</span> num_lit_codes, num_dist_codes, num_bit_lengths; mz_uint i, total_code_sizes_to_pack, num_packed_code_sizes, rle_z_count, rle_repeat_count, packed_code_sizes_index;</div>
<div class="line"><a name="l00848"></a><span class="lineno">  848</span>&#160;  mz_uint8 code_sizes_to_pack[TDEFL_MAX_HUFF_SYMBOLS_0 + TDEFL_MAX_HUFF_SYMBOLS_1], packed_code_sizes[TDEFL_MAX_HUFF_SYMBOLS_0 + TDEFL_MAX_HUFF_SYMBOLS_1], prev_code_size = 0xFF;</div>
<div class="line"><a name="l00849"></a><span class="lineno">  849</span>&#160;</div>
<div class="line"><a name="l00850"></a><span class="lineno">  850</span>&#160;  d-&gt;m_huff_count[0][256] = 1;</div>
<div class="line"><a name="l00851"></a><span class="lineno">  851</span>&#160;</div>
<div class="line"><a name="l00852"></a><span class="lineno">  852</span>&#160;  tdefl_optimize_huffman_table(d, 0, TDEFL_MAX_HUFF_SYMBOLS_0, 15, MZ_FALSE);</div>
<div class="line"><a name="l00853"></a><span class="lineno">  853</span>&#160;  tdefl_optimize_huffman_table(d, 1, TDEFL_MAX_HUFF_SYMBOLS_1, 15, MZ_FALSE);</div>
<div class="line"><a name="l00854"></a><span class="lineno">  854</span>&#160;</div>
<div class="line"><a name="l00855"></a><span class="lineno">  855</span>&#160;  <span class="keywordflow">for</span> (num_lit_codes = 286; num_lit_codes &gt; 257; num_lit_codes--) <span class="keywordflow">if</span> (d-&gt;m_huff_code_sizes[0][num_lit_codes - 1]) <span class="keywordflow">break</span>;</div>
<div class="line"><a name="l00856"></a><span class="lineno">  856</span>&#160;  <span class="keywordflow">for</span> (num_dist_codes = 30; num_dist_codes &gt; 1; num_dist_codes--) <span class="keywordflow">if</span> (d-&gt;m_huff_code_sizes[1][num_dist_codes - 1]) <span class="keywordflow">break</span>;</div>
<div class="line"><a name="l00857"></a><span class="lineno">  857</span>&#160;</div>
<div class="line"><a name="l00858"></a><span class="lineno">  858</span>&#160;  memcpy(code_sizes_to_pack, &amp;d-&gt;m_huff_code_sizes[0][0], num_lit_codes);</div>
<div class="line"><a name="l00859"></a><span class="lineno">  859</span>&#160;  memcpy(code_sizes_to_pack + num_lit_codes, &amp;d-&gt;m_huff_code_sizes[1][0], num_dist_codes);</div>
<div class="line"><a name="l00860"></a><span class="lineno">  860</span>&#160;  total_code_sizes_to_pack = num_lit_codes + num_dist_codes; num_packed_code_sizes = 0; rle_z_count = 0; rle_repeat_count = 0;</div>
<div class="line"><a name="l00861"></a><span class="lineno">  861</span>&#160;</div>
<div class="line"><a name="l00862"></a><span class="lineno">  862</span>&#160;  memset(&amp;d-&gt;m_huff_count[2][0], 0, <span class="keyword">sizeof</span>(d-&gt;m_huff_count[2][0]) * TDEFL_MAX_HUFF_SYMBOLS_2);</div>
<div class="line"><a name="l00863"></a><span class="lineno">  863</span>&#160;  <span class="keywordflow">for</span> (i = 0; i &lt; total_code_sizes_to_pack; i++)</div>
<div class="line"><a name="l00864"></a><span class="lineno">  864</span>&#160;  {</div>
<div class="line"><a name="l00865"></a><span class="lineno">  865</span>&#160;    mz_uint8 code_size = code_sizes_to_pack[i];</div>
<div class="line"><a name="l00866"></a><span class="lineno">  866</span>&#160;    <span class="keywordflow">if</span> (!code_size)</div>
<div class="line"><a name="l00867"></a><span class="lineno">  867</span>&#160;    {</div>
<div class="line"><a name="l00868"></a><span class="lineno">  868</span>&#160;      TDEFL_RLE_PREV_CODE_SIZE();</div>
<div class="line"><a name="l00869"></a><span class="lineno">  869</span>&#160;      <span class="keywordflow">if</span> (++rle_z_count == 138) { TDEFL_RLE_ZERO_CODE_SIZE(); }</div>
<div class="line"><a name="l00870"></a><span class="lineno">  870</span>&#160;    }</div>
<div class="line"><a name="l00871"></a><span class="lineno">  871</span>&#160;    <span class="keywordflow">else</span></div>
<div class="line"><a name="l00872"></a><span class="lineno">  872</span>&#160;    {</div>
<div class="line"><a name="l00873"></a><span class="lineno">  873</span>&#160;      TDEFL_RLE_ZERO_CODE_SIZE();</div>
<div class="line"><a name="l00874"></a><span class="lineno">  874</span>&#160;      <span class="keywordflow">if</span> (code_size != prev_code_size)</div>
<div class="line"><a name="l00875"></a><span class="lineno">  875</span>&#160;      {</div>
<div class="line"><a name="l00876"></a><span class="lineno">  876</span>&#160;        TDEFL_RLE_PREV_CODE_SIZE();</div>
<div class="line"><a name="l00877"></a><span class="lineno">  877</span>&#160;        d-&gt;m_huff_count[2][code_size] = (mz_uint16)(d-&gt;m_huff_count[2][code_size] + 1); packed_code_sizes[num_packed_code_sizes++] = code_size;</div>
<div class="line"><a name="l00878"></a><span class="lineno">  878</span>&#160;      }</div>
<div class="line"><a name="l00879"></a><span class="lineno">  879</span>&#160;      <span class="keywordflow">else</span> <span class="keywordflow">if</span> (++rle_repeat_count == 6)</div>
<div class="line"><a name="l00880"></a><span class="lineno">  880</span>&#160;      {</div>
<div class="line"><a name="l00881"></a><span class="lineno">  881</span>&#160;        TDEFL_RLE_PREV_CODE_SIZE();</div>
<div class="line"><a name="l00882"></a><span class="lineno">  882</span>&#160;      }</div>
<div class="line"><a name="l00883"></a><span class="lineno">  883</span>&#160;    }</div>
<div class="line"><a name="l00884"></a><span class="lineno">  884</span>&#160;    prev_code_size = code_size;</div>
<div class="line"><a name="l00885"></a><span class="lineno">  885</span>&#160;  }</div>
<div class="line"><a name="l00886"></a><span class="lineno">  886</span>&#160;  <span class="keywordflow">if</span> (rle_repeat_count) { TDEFL_RLE_PREV_CODE_SIZE(); } <span class="keywordflow">else</span> { TDEFL_RLE_ZERO_CODE_SIZE(); }</div>
<div class="line"><a name="l00887"></a><span class="lineno">  887</span>&#160;</div>
<div class="line"><a name="l00888"></a><span class="lineno">  888</span>&#160;  tdefl_optimize_huffman_table(d, 2, TDEFL_MAX_HUFF_SYMBOLS_2, 7, MZ_FALSE);</div>
<div class="line"><a name="l00889"></a><span class="lineno">  889</span>&#160;</div>
<div class="line"><a name="l00890"></a><span class="lineno">  890</span>&#160;  TDEFL_PUT_BITS(2, 2);</div>
<div class="line"><a name="l00891"></a><span class="lineno">  891</span>&#160;</div>
<div class="line"><a name="l00892"></a><span class="lineno">  892</span>&#160;  TDEFL_PUT_BITS(num_lit_codes - 257, 5);</div>
<div class="line"><a name="l00893"></a><span class="lineno">  893</span>&#160;  TDEFL_PUT_BITS(num_dist_codes - 1, 5);</div>
<div class="line"><a name="l00894"></a><span class="lineno">  894</span>&#160;</div>
<div class="line"><a name="l00895"></a><span class="lineno">  895</span>&#160;  <span class="keywordflow">for</span> (num_bit_lengths = 18; num_bit_lengths &gt;= 0; num_bit_lengths--) <span class="keywordflow">if</span> (d-&gt;m_huff_code_sizes[2][s_tdefl_packed_code_size_syms_swizzle[num_bit_lengths]]) <span class="keywordflow">break</span>;</div>
<div class="line"><a name="l00896"></a><span class="lineno">  896</span>&#160;  num_bit_lengths = MZ_MAX(4, (num_bit_lengths + 1)); TDEFL_PUT_BITS(num_bit_lengths - 4, 4);</div>
<div class="line"><a name="l00897"></a><span class="lineno">  897</span>&#160;  <span class="keywordflow">for</span> (i = 0; (int)i &lt; num_bit_lengths; i++) TDEFL_PUT_BITS(d-&gt;m_huff_code_sizes[2][s_tdefl_packed_code_size_syms_swizzle[i]], 3);</div>
<div class="line"><a name="l00898"></a><span class="lineno">  898</span>&#160;</div>
<div class="line"><a name="l00899"></a><span class="lineno">  899</span>&#160;  <span class="keywordflow">for</span> (packed_code_sizes_index = 0; packed_code_sizes_index &lt; num_packed_code_sizes; )</div>
<div class="line"><a name="l00900"></a><span class="lineno">  900</span>&#160;  {</div>
<div class="line"><a name="l00901"></a><span class="lineno">  901</span>&#160;    mz_uint code = packed_code_sizes[packed_code_sizes_index++]; assert(code &lt; TDEFL_MAX_HUFF_SYMBOLS_2);</div>
<div class="line"><a name="l00902"></a><span class="lineno">  902</span>&#160;    TDEFL_PUT_BITS(d-&gt;m_huff_codes[2][code], d-&gt;m_huff_code_sizes[2][code]);</div>
<div class="line"><a name="l00903"></a><span class="lineno">  903</span>&#160;    <span class="keywordflow">if</span> (code &gt;= 16) TDEFL_PUT_BITS(packed_code_sizes[packed_code_sizes_index++], <span class="stringliteral">&quot;\02\03\07&quot;</span>[code - 16]);</div>
<div class="line"><a name="l00904"></a><span class="lineno">  904</span>&#160;  }</div>
<div class="line"><a name="l00905"></a><span class="lineno">  905</span>&#160;}</div>
<div class="line"><a name="l00906"></a><span class="lineno">  906</span>&#160;</div>
<div class="line"><a name="l00907"></a><span class="lineno">  907</span>&#160;<span class="keyword">static</span> <span class="keywordtype">void</span> tdefl_start_static_block(tdefl_compressor *d)</div>
<div class="line"><a name="l00908"></a><span class="lineno">  908</span>&#160;{</div>
<div class="line"><a name="l00909"></a><span class="lineno">  909</span>&#160;  mz_uint i;</div>
<div class="line"><a name="l00910"></a><span class="lineno">  910</span>&#160;  mz_uint8 *p = &amp;d-&gt;m_huff_code_sizes[0][0];</div>
<div class="line"><a name="l00911"></a><span class="lineno">  911</span>&#160;</div>
<div class="line"><a name="l00912"></a><span class="lineno">  912</span>&#160;  <span class="keywordflow">for</span> (i = 0; i &lt;= 143; ++i) *p++ = 8;</div>
<div class="line"><a name="l00913"></a><span class="lineno">  913</span>&#160;  <span class="keywordflow">for</span> ( ; i &lt;= 255; ++i) *p++ = 9;</div>
<div class="line"><a name="l00914"></a><span class="lineno">  914</span>&#160;  <span class="keywordflow">for</span> ( ; i &lt;= 279; ++i) *p++ = 7;</div>
<div class="line"><a name="l00915"></a><span class="lineno">  915</span>&#160;  <span class="keywordflow">for</span> ( ; i &lt;= 287; ++i) *p++ = 8;</div>
<div class="line"><a name="l00916"></a><span class="lineno">  916</span>&#160;</div>
<div class="line"><a name="l00917"></a><span class="lineno">  917</span>&#160;  memset(d-&gt;m_huff_code_sizes[1], 5, 32);</div>
<div class="line"><a name="l00918"></a><span class="lineno">  918</span>&#160;</div>
<div class="line"><a name="l00919"></a><span class="lineno">  919</span>&#160;  tdefl_optimize_huffman_table(d, 0, 288, 15, MZ_TRUE);</div>
<div class="line"><a name="l00920"></a><span class="lineno">  920</span>&#160;  tdefl_optimize_huffman_table(d, 1, 32, 15, MZ_TRUE);</div>
<div class="line"><a name="l00921"></a><span class="lineno">  921</span>&#160;</div>
<div class="line"><a name="l00922"></a><span class="lineno">  922</span>&#160;  TDEFL_PUT_BITS(1, 2);</div>
<div class="line"><a name="l00923"></a><span class="lineno">  923</span>&#160;}</div>
<div class="line"><a name="l00924"></a><span class="lineno">  924</span>&#160;</div>
<div class="line"><a name="l00925"></a><span class="lineno">  925</span>&#160;<span class="keyword">static</span> <span class="keyword">const</span> mz_uint mz_bitmasks[17] = { 0x0000, 0x0001, 0x0003, 0x0007, 0x000F, 0x001F, 0x003F, 0x007F, 0x00FF, 0x01FF, 0x03FF, 0x07FF, 0x0FFF, 0x1FFF, 0x3FFF, 0x7FFF, 0xFFFF };</div>
<div class="line"><a name="l00926"></a><span class="lineno">  926</span>&#160;</div>
<div class="line"><a name="l00927"></a><span class="lineno">  927</span>&#160;<span class="keyword">static</span> mz_bool tdefl_compress_lz_codes(tdefl_compressor *d)</div>
<div class="line"><a name="l00928"></a><span class="lineno">  928</span>&#160;{</div>
<div class="line"><a name="l00929"></a><span class="lineno">  929</span>&#160;  mz_uint flags;</div>
<div class="line"><a name="l00930"></a><span class="lineno">  930</span>&#160;  mz_uint8 *pLZ_codes;</div>
<div class="line"><a name="l00931"></a><span class="lineno">  931</span>&#160;  mz_uint8 *pOutput_buf = d-&gt;m_pOutput_buf;</div>
<div class="line"><a name="l00932"></a><span class="lineno">  932</span>&#160;  mz_uint8 *pLZ_code_buf_end = d-&gt;m_pLZ_code_buf;</div>
<div class="line"><a name="l00933"></a><span class="lineno">  933</span>&#160;  mz_uint64 bit_buffer = d-&gt;m_bit_buffer;</div>
<div class="line"><a name="l00934"></a><span class="lineno">  934</span>&#160;  mz_uint bits_in = d-&gt;m_bits_in;</div>
<div class="line"><a name="l00935"></a><span class="lineno">  935</span>&#160;</div>
<div class="line"><a name="l00936"></a><span class="lineno">  936</span>&#160;<span class="preprocessor">#define TDEFL_PUT_BITS_FAST(b, l) { bit_buffer |= (((mz_uint64)(b)) &lt;&lt; bits_in); bits_in += (l); }</span></div>
<div class="line"><a name="l00937"></a><span class="lineno">  937</span>&#160;<span class="preprocessor"></span></div>
<div class="line"><a name="l00938"></a><span class="lineno">  938</span>&#160;  flags = 1;</div>
<div class="line"><a name="l00939"></a><span class="lineno">  939</span>&#160;  <span class="keywordflow">for</span> (pLZ_codes = d-&gt;m_lz_code_buf; pLZ_codes &lt; pLZ_code_buf_end; flags &gt;&gt;= 1)</div>
<div class="line"><a name="l00940"></a><span class="lineno">  940</span>&#160;  {</div>
<div class="line"><a name="l00941"></a><span class="lineno">  941</span>&#160;    <span class="keywordflow">if</span> (flags == 1)</div>
<div class="line"><a name="l00942"></a><span class="lineno">  942</span>&#160;      flags = *pLZ_codes++ | 0x100;</div>
<div class="line"><a name="l00943"></a><span class="lineno">  943</span>&#160;</div>
<div class="line"><a name="l00944"></a><span class="lineno">  944</span>&#160;    <span class="keywordflow">if</span> (flags &amp; 1)</div>
<div class="line"><a name="l00945"></a><span class="lineno">  945</span>&#160;    {</div>
<div class="line"><a name="l00946"></a><span class="lineno">  946</span>&#160;      mz_uint s0, s1, n0, n1, sym, num_extra_bits;</div>
<div class="line"><a name="l00947"></a><span class="lineno">  947</span>&#160;      mz_uint match_len = pLZ_codes[0], match_dist = *(<span class="keyword">const</span> mz_uint16 *)(pLZ_codes + 1); pLZ_codes += 3;</div>
<div class="line"><a name="l00948"></a><span class="lineno">  948</span>&#160;</div>
<div class="line"><a name="l00949"></a><span class="lineno">  949</span>&#160;      assert(d-&gt;m_huff_code_sizes[0][s_tdefl_len_sym[match_len]]);</div>
<div class="line"><a name="l00950"></a><span class="lineno">  950</span>&#160;      TDEFL_PUT_BITS_FAST(d-&gt;m_huff_codes[0][s_tdefl_len_sym[match_len]], d-&gt;m_huff_code_sizes[0][s_tdefl_len_sym[match_len]]);</div>
<div class="line"><a name="l00951"></a><span class="lineno">  951</span>&#160;      TDEFL_PUT_BITS_FAST(match_len &amp; mz_bitmasks[s_tdefl_len_extra[match_len]], s_tdefl_len_extra[match_len]);</div>
<div class="line"><a name="l00952"></a><span class="lineno">  952</span>&#160;</div>
<div class="line"><a name="l00953"></a><span class="lineno">  953</span>&#160;      <span class="comment">// This sequence coaxes MSVC into using cmov&#39;s vs. jmp&#39;s.</span></div>
<div class="line"><a name="l00954"></a><span class="lineno">  954</span>&#160;      s0 = s_tdefl_small_dist_sym[match_dist &amp; 511];</div>
<div class="line"><a name="l00955"></a><span class="lineno">  955</span>&#160;      n0 = s_tdefl_small_dist_extra[match_dist &amp; 511];</div>
<div class="line"><a name="l00956"></a><span class="lineno">  956</span>&#160;      s1 = s_tdefl_large_dist_sym[match_dist &gt;&gt; 8];</div>
<div class="line"><a name="l00957"></a><span class="lineno">  957</span>&#160;      n1 = s_tdefl_large_dist_extra[match_dist &gt;&gt; 8];</div>
<div class="line"><a name="l00958"></a><span class="lineno">  958</span>&#160;      sym = (match_dist &lt; 512) ? s0 : s1;</div>
<div class="line"><a name="l00959"></a><span class="lineno">  959</span>&#160;      num_extra_bits = (match_dist &lt; 512) ? n0 : n1;</div>
<div class="line"><a name="l00960"></a><span class="lineno">  960</span>&#160;</div>
<div class="line"><a name="l00961"></a><span class="lineno">  961</span>&#160;      assert(d-&gt;m_huff_code_sizes[1][sym]);</div>
<div class="line"><a name="l00962"></a><span class="lineno">  962</span>&#160;      TDEFL_PUT_BITS_FAST(d-&gt;m_huff_codes[1][sym], d-&gt;m_huff_code_sizes[1][sym]);</div>
<div class="line"><a name="l00963"></a><span class="lineno">  963</span>&#160;      TDEFL_PUT_BITS_FAST(match_dist &amp; mz_bitmasks[num_extra_bits], num_extra_bits);</div>
<div class="line"><a name="l00964"></a><span class="lineno">  964</span>&#160;    }</div>
<div class="line"><a name="l00965"></a><span class="lineno">  965</span>&#160;    <span class="keywordflow">else</span></div>
<div class="line"><a name="l00966"></a><span class="lineno">  966</span>&#160;    {</div>
<div class="line"><a name="l00967"></a><span class="lineno">  967</span>&#160;      mz_uint lit = *pLZ_codes++;</div>
<div class="line"><a name="l00968"></a><span class="lineno">  968</span>&#160;      assert(d-&gt;m_huff_code_sizes[0][lit]);</div>
<div class="line"><a name="l00969"></a><span class="lineno">  969</span>&#160;      TDEFL_PUT_BITS_FAST(d-&gt;m_huff_codes[0][lit], d-&gt;m_huff_code_sizes[0][lit]);</div>
<div class="line"><a name="l00970"></a><span class="lineno">  970</span>&#160;</div>
<div class="line"><a name="l00971"></a><span class="lineno">  971</span>&#160;      <span class="keywordflow">if</span> (((flags &amp; 2) == 0) &amp;&amp; (pLZ_codes &lt; pLZ_code_buf_end))</div>
<div class="line"><a name="l00972"></a><span class="lineno">  972</span>&#160;      {</div>
<div class="line"><a name="l00973"></a><span class="lineno">  973</span>&#160;        flags &gt;&gt;= 1;</div>
<div class="line"><a name="l00974"></a><span class="lineno">  974</span>&#160;        lit = *pLZ_codes++;</div>
<div class="line"><a name="l00975"></a><span class="lineno">  975</span>&#160;        assert(d-&gt;m_huff_code_sizes[0][lit]);</div>
<div class="line"><a name="l00976"></a><span class="lineno">  976</span>&#160;        TDEFL_PUT_BITS_FAST(d-&gt;m_huff_codes[0][lit], d-&gt;m_huff_code_sizes[0][lit]);</div>
<div class="line"><a name="l00977"></a><span class="lineno">  977</span>&#160;</div>
<div class="line"><a name="l00978"></a><span class="lineno">  978</span>&#160;        <span class="keywordflow">if</span> (((flags &amp; 2) == 0) &amp;&amp; (pLZ_codes &lt; pLZ_code_buf_end))</div>
<div class="line"><a name="l00979"></a><span class="lineno">  979</span>&#160;        {</div>
<div class="line"><a name="l00980"></a><span class="lineno">  980</span>&#160;          flags &gt;&gt;= 1;</div>
<div class="line"><a name="l00981"></a><span class="lineno">  981</span>&#160;          lit = *pLZ_codes++;</div>
<div class="line"><a name="l00982"></a><span class="lineno">  982</span>&#160;          assert(d-&gt;m_huff_code_sizes[0][lit]);</div>
<div class="line"><a name="l00983"></a><span class="lineno">  983</span>&#160;          TDEFL_PUT_BITS_FAST(d-&gt;m_huff_codes[0][lit], d-&gt;m_huff_code_sizes[0][lit]);</div>
<div class="line"><a name="l00984"></a><span class="lineno">  984</span>&#160;        }</div>
<div class="line"><a name="l00985"></a><span class="lineno">  985</span>&#160;      }</div>
<div class="line"><a name="l00986"></a><span class="lineno">  986</span>&#160;    }</div>
<div class="line"><a name="l00987"></a><span class="lineno">  987</span>&#160;</div>
<div class="line"><a name="l00988"></a><span class="lineno">  988</span>&#160;    <span class="keywordflow">if</span> (pOutput_buf &gt;= d-&gt;m_pOutput_buf_end)</div>
<div class="line"><a name="l00989"></a><span class="lineno">  989</span>&#160;      <span class="keywordflow">return</span> MZ_FALSE;</div>
<div class="line"><a name="l00990"></a><span class="lineno">  990</span>&#160;</div>
<div class="line"><a name="l00991"></a><span class="lineno">  991</span>&#160;    *(mz_uint64*)pOutput_buf = bit_buffer;</div>
<div class="line"><a name="l00992"></a><span class="lineno">  992</span>&#160;    pOutput_buf += (bits_in &gt;&gt; 3);</div>
<div class="line"><a name="l00993"></a><span class="lineno">  993</span>&#160;    bit_buffer &gt;&gt;= (bits_in &amp; ~7);</div>
<div class="line"><a name="l00994"></a><span class="lineno">  994</span>&#160;    bits_in &amp;= 7;</div>
<div class="line"><a name="l00995"></a><span class="lineno">  995</span>&#160;  }</div>
<div class="line"><a name="l00996"></a><span class="lineno">  996</span>&#160;</div>
<div class="line"><a name="l00997"></a><span class="lineno">  997</span>&#160;<span class="preprocessor">#undef TDEFL_PUT_BITS_FAST</span></div>
<div class="line"><a name="l00998"></a><span class="lineno">  998</span>&#160;<span class="preprocessor"></span></div>
<div class="line"><a name="l00999"></a><span class="lineno">  999</span>&#160;  d-&gt;m_pOutput_buf = pOutput_buf;</div>
<div class="line"><a name="l01000"></a><span class="lineno"> 1000</span>&#160;  d-&gt;m_bits_in = 0;</div>
<div class="line"><a name="l01001"></a><span class="lineno"> 1001</span>&#160;  d-&gt;m_bit_buffer = 0;</div>
<div class="line"><a name="l01002"></a><span class="lineno"> 1002</span>&#160;</div>
<div class="line"><a name="l01003"></a><span class="lineno"> 1003</span>&#160;  <span class="keywordflow">while</span> (bits_in)</div>
<div class="line"><a name="l01004"></a><span class="lineno"> 1004</span>&#160;  {</div>
<div class="line"><a name="l01005"></a><span class="lineno"> 1005</span>&#160;    mz_uint32 n = MZ_MIN(bits_in, 16);</div>
<div class="line"><a name="l01006"></a><span class="lineno"> 1006</span>&#160;    TDEFL_PUT_BITS((mz_uint)bit_buffer &amp; mz_bitmasks[n], n);</div>
<div class="line"><a name="l01007"></a><span class="lineno"> 1007</span>&#160;    bit_buffer &gt;&gt;= n;</div>
<div class="line"><a name="l01008"></a><span class="lineno"> 1008</span>&#160;    bits_in -= n;</div>
<div class="line"><a name="l01009"></a><span class="lineno"> 1009</span>&#160;  }</div>
<div class="line"><a name="l01010"></a><span class="lineno"> 1010</span>&#160;</div>
<div class="line"><a name="l01011"></a><span class="lineno"> 1011</span>&#160;  TDEFL_PUT_BITS(d-&gt;m_huff_codes[0][256], d-&gt;m_huff_code_sizes[0][256]);</div>
<div class="line"><a name="l01012"></a><span class="lineno"> 1012</span>&#160;</div>
<div class="line"><a name="l01013"></a><span class="lineno"> 1013</span>&#160;  <span class="keywordflow">return</span> (d-&gt;m_pOutput_buf &lt; d-&gt;m_pOutput_buf_end);</div>
<div class="line"><a name="l01014"></a><span class="lineno"> 1014</span>&#160;}</div>
<div class="line"><a name="l01015"></a><span class="lineno"> 1015</span>&#160;</div>
<div class="line"><a name="l01016"></a><span class="lineno"> 1016</span>&#160;<span class="keyword">static</span> mz_bool tdefl_compress_block(tdefl_compressor *d, mz_bool static_block)</div>
<div class="line"><a name="l01017"></a><span class="lineno"> 1017</span>&#160;{</div>
<div class="line"><a name="l01018"></a><span class="lineno"> 1018</span>&#160;  <span class="keywordflow">if</span> (static_block)</div>
<div class="line"><a name="l01019"></a><span class="lineno"> 1019</span>&#160;    tdefl_start_static_block(d);</div>
<div class="line"><a name="l01020"></a><span class="lineno"> 1020</span>&#160;  <span class="keywordflow">else</span></div>
<div class="line"><a name="l01021"></a><span class="lineno"> 1021</span>&#160;    tdefl_start_dynamic_block(d);</div>
<div class="line"><a name="l01022"></a><span class="lineno"> 1022</span>&#160;  <span class="keywordflow">return</span> tdefl_compress_lz_codes(d);</div>
<div class="line"><a name="l01023"></a><span class="lineno"> 1023</span>&#160;}</div>
<div class="line"><a name="l01024"></a><span class="lineno"> 1024</span>&#160;</div>
<div class="line"><a name="l01025"></a><span class="lineno"> 1025</span>&#160;<span class="keyword">static</span> <span class="keywordtype">int</span> tdefl_flush_block(tdefl_compressor *d, <span class="keywordtype">int</span> flush)</div>
<div class="line"><a name="l01026"></a><span class="lineno"> 1026</span>&#160;{</div>
<div class="line"><a name="l01027"></a><span class="lineno"> 1027</span>&#160;  mz_uint saved_bit_buf, saved_bits_in;</div>
<div class="line"><a name="l01028"></a><span class="lineno"> 1028</span>&#160;  mz_uint8 *pSaved_output_buf;</div>
<div class="line"><a name="l01029"></a><span class="lineno"> 1029</span>&#160;  mz_bool comp_block_succeeded = MZ_FALSE;</div>
<div class="line"><a name="l01030"></a><span class="lineno"> 1030</span>&#160;  <span class="keywordtype">int</span> n, use_raw_block = ((d-&gt;m_flags &amp; TDEFL_FORCE_ALL_RAW_BLOCKS) != 0) &amp;&amp; (d-&gt;m_lookahead_pos - d-&gt;m_lz_code_buf_dict_pos) &lt;= d-&gt;m_dict_size;</div>
<div class="line"><a name="l01031"></a><span class="lineno"> 1031</span>&#160;  mz_uint8 *pOutput_buf_start = ((d-&gt;m_pPut_buf_func == NULL) &amp;&amp; ((*d-&gt;m_pOut_buf_size - d-&gt;m_out_buf_ofs) &gt;= TDEFL_OUT_BUF_SIZE)) ? ((mz_uint8 *)d-&gt;m_pOut_buf + d-&gt;m_out_buf_ofs) : d-&gt;m_output_buf;</div>
<div class="line"><a name="l01032"></a><span class="lineno"> 1032</span>&#160;</div>
<div class="line"><a name="l01033"></a><span class="lineno"> 1033</span>&#160;  d-&gt;m_pOutput_buf = pOutput_buf_start;</div>
<div class="line"><a name="l01034"></a><span class="lineno"> 1034</span>&#160;  d-&gt;m_pOutput_buf_end = d-&gt;m_pOutput_buf + TDEFL_OUT_BUF_SIZE - 16;</div>
<div class="line"><a name="l01035"></a><span class="lineno"> 1035</span>&#160;</div>
<div class="line"><a name="l01036"></a><span class="lineno"> 1036</span>&#160;  assert(!d-&gt;m_output_flush_remaining);</div>
<div class="line"><a name="l01037"></a><span class="lineno"> 1037</span>&#160;  d-&gt;m_output_flush_ofs = 0;</div>
<div class="line"><a name="l01038"></a><span class="lineno"> 1038</span>&#160;  d-&gt;m_output_flush_remaining = 0;</div>
<div class="line"><a name="l01039"></a><span class="lineno"> 1039</span>&#160;</div>
<div class="line"><a name="l01040"></a><span class="lineno"> 1040</span>&#160;  *d-&gt;m_pLZ_flags = (mz_uint8)(*d-&gt;m_pLZ_flags &gt;&gt; d-&gt;m_num_flags_left);</div>
<div class="line"><a name="l01041"></a><span class="lineno"> 1041</span>&#160;  d-&gt;m_pLZ_code_buf -= (d-&gt;m_num_flags_left == 8);</div>
<div class="line"><a name="l01042"></a><span class="lineno"> 1042</span>&#160;</div>
<div class="line"><a name="l01043"></a><span class="lineno"> 1043</span>&#160;  <span class="keywordflow">if</span> ((d-&gt;m_flags &amp; TDEFL_WRITE_ZLIB_HEADER) &amp;&amp; (!d-&gt;m_block_index))</div>
<div class="line"><a name="l01044"></a><span class="lineno"> 1044</span>&#160;  {</div>
<div class="line"><a name="l01045"></a><span class="lineno"> 1045</span>&#160;    TDEFL_PUT_BITS(0x78, 8); TDEFL_PUT_BITS(0x01, 8);</div>
<div class="line"><a name="l01046"></a><span class="lineno"> 1046</span>&#160;  }</div>
<div class="line"><a name="l01047"></a><span class="lineno"> 1047</span>&#160;</div>
<div class="line"><a name="l01048"></a><span class="lineno"> 1048</span>&#160;  TDEFL_PUT_BITS(flush == TDEFL_FINISH, 1);</div>
<div class="line"><a name="l01049"></a><span class="lineno"> 1049</span>&#160;</div>
<div class="line"><a name="l01050"></a><span class="lineno"> 1050</span>&#160;  pSaved_output_buf = d-&gt;m_pOutput_buf; saved_bit_buf = d-&gt;m_bit_buffer; saved_bits_in = d-&gt;m_bits_in;</div>
<div class="line"><a name="l01051"></a><span class="lineno"> 1051</span>&#160;</div>
<div class="line"><a name="l01052"></a><span class="lineno"> 1052</span>&#160;  <span class="keywordflow">if</span> (!use_raw_block)</div>
<div class="line"><a name="l01053"></a><span class="lineno"> 1053</span>&#160;    comp_block_succeeded = tdefl_compress_block(d, (d-&gt;m_flags &amp; TDEFL_FORCE_ALL_STATIC_BLOCKS) || (d-&gt;m_total_lz_bytes &lt; 48));</div>
<div class="line"><a name="l01054"></a><span class="lineno"> 1054</span>&#160;</div>
<div class="line"><a name="l01055"></a><span class="lineno"> 1055</span>&#160;  <span class="comment">// If the block gets expanded, forget the current contents of the output buffer and send a raw block instead.</span></div>
<div class="line"><a name="l01056"></a><span class="lineno"> 1056</span>&#160;  <span class="keywordflow">if</span> ( ((use_raw_block) || ((d-&gt;m_total_lz_bytes) &amp;&amp; ((d-&gt;m_pOutput_buf - pSaved_output_buf + 1U) &gt;= d-&gt;m_total_lz_bytes))) &amp;&amp;</div>
<div class="line"><a name="l01057"></a><span class="lineno"> 1057</span>&#160;       ((d-&gt;m_lookahead_pos - d-&gt;m_lz_code_buf_dict_pos) &lt;= d-&gt;m_dict_size) )</div>
<div class="line"><a name="l01058"></a><span class="lineno"> 1058</span>&#160;  {</div>
<div class="line"><a name="l01059"></a><span class="lineno"> 1059</span>&#160;    mz_uint i; d-&gt;m_pOutput_buf = pSaved_output_buf; d-&gt;m_bit_buffer = saved_bit_buf, d-&gt;m_bits_in = saved_bits_in;</div>
<div class="line"><a name="l01060"></a><span class="lineno"> 1060</span>&#160;    TDEFL_PUT_BITS(0, 2);</div>
<div class="line"><a name="l01061"></a><span class="lineno"> 1061</span>&#160;    <span class="keywordflow">if</span> (d-&gt;m_bits_in) { TDEFL_PUT_BITS(0, 8 - d-&gt;m_bits_in); }</div>
<div class="line"><a name="l01062"></a><span class="lineno"> 1062</span>&#160;    <span class="keywordflow">for</span> (i = 2; i; --i, d-&gt;m_total_lz_bytes ^= 0xFFFF)</div>
<div class="line"><a name="l01063"></a><span class="lineno"> 1063</span>&#160;    {</div>
<div class="line"><a name="l01064"></a><span class="lineno"> 1064</span>&#160;      TDEFL_PUT_BITS(d-&gt;m_total_lz_bytes &amp; 0xFFFF, 16);</div>
<div class="line"><a name="l01065"></a><span class="lineno"> 1065</span>&#160;    }</div>
<div class="line"><a name="l01066"></a><span class="lineno"> 1066</span>&#160;    <span class="keywordflow">for</span> (i = 0; i &lt; d-&gt;m_total_lz_bytes; ++i)</div>
<div class="line"><a name="l01067"></a><span class="lineno"> 1067</span>&#160;    {</div>
<div class="line"><a name="l01068"></a><span class="lineno"> 1068</span>&#160;      TDEFL_PUT_BITS(d-&gt;m_dict[(d-&gt;m_lz_code_buf_dict_pos + i) &amp; TDEFL_LZ_DICT_SIZE_MASK], 8);</div>
<div class="line"><a name="l01069"></a><span class="lineno"> 1069</span>&#160;    }</div>
<div class="line"><a name="l01070"></a><span class="lineno"> 1070</span>&#160;  }</div>
<div class="line"><a name="l01071"></a><span class="lineno"> 1071</span>&#160;  <span class="comment">// Check for the extremely unlikely (if not impossible) case of the compressed block not fitting into the output buffer when using dynamic codes.</span></div>
<div class="line"><a name="l01072"></a><span class="lineno"> 1072</span>&#160;  <span class="keywordflow">else</span> <span class="keywordflow">if</span> (!comp_block_succeeded)</div>
<div class="line"><a name="l01073"></a><span class="lineno"> 1073</span>&#160;  {</div>
<div class="line"><a name="l01074"></a><span class="lineno"> 1074</span>&#160;    d-&gt;m_pOutput_buf = pSaved_output_buf; d-&gt;m_bit_buffer = saved_bit_buf, d-&gt;m_bits_in = saved_bits_in;</div>
<div class="line"><a name="l01075"></a><span class="lineno"> 1075</span>&#160;    tdefl_compress_block(d, MZ_TRUE);</div>
<div class="line"><a name="l01076"></a><span class="lineno"> 1076</span>&#160;  }</div>
<div class="line"><a name="l01077"></a><span class="lineno"> 1077</span>&#160;</div>
<div class="line"><a name="l01078"></a><span class="lineno"> 1078</span>&#160;  <span class="keywordflow">if</span> (flush)</div>
<div class="line"><a name="l01079"></a><span class="lineno"> 1079</span>&#160;  {</div>
<div class="line"><a name="l01080"></a><span class="lineno"> 1080</span>&#160;    <span class="keywordflow">if</span> (flush == TDEFL_FINISH)</div>
<div class="line"><a name="l01081"></a><span class="lineno"> 1081</span>&#160;    {</div>
<div class="line"><a name="l01082"></a><span class="lineno"> 1082</span>&#160;      <span class="keywordflow">if</span> (d-&gt;m_bits_in) { TDEFL_PUT_BITS(0, 8 - d-&gt;m_bits_in); }</div>
<div class="line"><a name="l01083"></a><span class="lineno"> 1083</span>&#160;      <span class="keywordflow">if</span> (d-&gt;m_flags &amp; TDEFL_WRITE_ZLIB_HEADER) { mz_uint i, a = d-&gt;m_adler32; <span class="keywordflow">for</span> (i = 0; i &lt; 4; i++) { TDEFL_PUT_BITS((a &gt;&gt; 24) &amp; 0xFF, 8); a &lt;&lt;= 8; } }</div>
<div class="line"><a name="l01084"></a><span class="lineno"> 1084</span>&#160;    }</div>
<div class="line"><a name="l01085"></a><span class="lineno"> 1085</span>&#160;    <span class="keywordflow">else</span></div>
<div class="line"><a name="l01086"></a><span class="lineno"> 1086</span>&#160;    {</div>
<div class="line"><a name="l01087"></a><span class="lineno"> 1087</span>&#160;      mz_uint i, z = 0; TDEFL_PUT_BITS(0, 3); <span class="keywordflow">if</span> (d-&gt;m_bits_in) { TDEFL_PUT_BITS(0, 8 - d-&gt;m_bits_in); } <span class="keywordflow">for</span> (i = 2; i; --i, z ^= 0xFFFF) { TDEFL_PUT_BITS(z &amp; 0xFFFF, 16); }</div>
<div class="line"><a name="l01088"></a><span class="lineno"> 1088</span>&#160;    }</div>
<div class="line"><a name="l01089"></a><span class="lineno"> 1089</span>&#160;  }</div>
<div class="line"><a name="l01090"></a><span class="lineno"> 1090</span>&#160;</div>
<div class="line"><a name="l01091"></a><span class="lineno"> 1091</span>&#160;  assert(d-&gt;m_pOutput_buf &lt; d-&gt;m_pOutput_buf_end);</div>
<div class="line"><a name="l01092"></a><span class="lineno"> 1092</span>&#160;</div>
<div class="line"><a name="l01093"></a><span class="lineno"> 1093</span>&#160;  memset(&amp;d-&gt;m_huff_count[0][0], 0, <span class="keyword">sizeof</span>(d-&gt;m_huff_count[0][0]) * TDEFL_MAX_HUFF_SYMBOLS_0);</div>
<div class="line"><a name="l01094"></a><span class="lineno"> 1094</span>&#160;  memset(&amp;d-&gt;m_huff_count[1][0], 0, <span class="keyword">sizeof</span>(d-&gt;m_huff_count[1][0]) * TDEFL_MAX_HUFF_SYMBOLS_1);</div>
<div class="line"><a name="l01095"></a><span class="lineno"> 1095</span>&#160;</div>
<div class="line"><a name="l01096"></a><span class="lineno"> 1096</span>&#160;  d-&gt;m_pLZ_code_buf = d-&gt;m_lz_code_buf + 1; d-&gt;m_pLZ_flags = d-&gt;m_lz_code_buf; d-&gt;m_num_flags_left = 8; d-&gt;m_lz_code_buf_dict_pos += d-&gt;m_total_lz_bytes; d-&gt;m_total_lz_bytes = 0; d-&gt;m_block_index++;</div>
<div class="line"><a name="l01097"></a><span class="lineno"> 1097</span>&#160;</div>
<div class="line"><a name="l01098"></a><span class="lineno"> 1098</span>&#160;  <span class="keywordflow">if</span> ((n = (<span class="keywordtype">int</span>)(d-&gt;m_pOutput_buf - pOutput_buf_start)) != 0)</div>
<div class="line"><a name="l01099"></a><span class="lineno"> 1099</span>&#160;  {</div>
<div class="line"><a name="l01100"></a><span class="lineno"> 1100</span>&#160;    <span class="keywordflow">if</span> (d-&gt;m_pPut_buf_func)</div>
<div class="line"><a name="l01101"></a><span class="lineno"> 1101</span>&#160;    {</div>
<div class="line"><a name="l01102"></a><span class="lineno"> 1102</span>&#160;      *d-&gt;m_pIn_buf_size = d-&gt;m_pSrc - (<span class="keyword">const</span> mz_uint8 *)d-&gt;m_pIn_buf;</div>
<div class="line"><a name="l01103"></a><span class="lineno"> 1103</span>&#160;      if (!(*d-&gt;m_pPut_buf_func)(d-&gt;m_output_buf, n, d-&gt;m_pPut_buf_user))</div>
<div class="line"><a name="l01104"></a><span class="lineno"> 1104</span>&#160;        <span class="keywordflow">return</span> (d-&gt;m_prev_return_status = TDEFL_STATUS_PUT_BUF_FAILED);</div>
<div class="line"><a name="l01105"></a><span class="lineno"> 1105</span>&#160;    }</div>
<div class="line"><a name="l01106"></a><span class="lineno"> 1106</span>&#160;    <span class="keywordflow">else</span> <span class="keywordflow">if</span> (pOutput_buf_start == d-&gt;m_output_buf)</div>
<div class="line"><a name="l01107"></a><span class="lineno"> 1107</span>&#160;    {</div>
<div class="line"><a name="l01108"></a><span class="lineno"> 1108</span>&#160;      <span class="keywordtype">int</span> bytes_to_copy = (int)MZ_MIN((<span class="keywordtype">size_t</span>)n, (size_t)(*d-&gt;m_pOut_buf_size - d-&gt;m_out_buf_ofs));</div>
<div class="line"><a name="l01109"></a><span class="lineno"> 1109</span>&#160;      memcpy((mz_uint8 *)d-&gt;m_pOut_buf + d-&gt;m_out_buf_ofs, d-&gt;m_output_buf, bytes_to_copy);</div>
<div class="line"><a name="l01110"></a><span class="lineno"> 1110</span>&#160;      d-&gt;m_out_buf_ofs += bytes_to_copy;</div>
<div class="line"><a name="l01111"></a><span class="lineno"> 1111</span>&#160;      <span class="keywordflow">if</span> ((n -= bytes_to_copy) != 0)</div>
<div class="line"><a name="l01112"></a><span class="lineno"> 1112</span>&#160;      {</div>
<div class="line"><a name="l01113"></a><span class="lineno"> 1113</span>&#160;        d-&gt;m_output_flush_ofs = bytes_to_copy;</div>
<div class="line"><a name="l01114"></a><span class="lineno"> 1114</span>&#160;        d-&gt;m_output_flush_remaining = n;</div>
<div class="line"><a name="l01115"></a><span class="lineno"> 1115</span>&#160;      }</div>
<div class="line"><a name="l01116"></a><span class="lineno"> 1116</span>&#160;    }</div>
<div class="line"><a name="l01117"></a><span class="lineno"> 1117</span>&#160;    <span class="keywordflow">else</span></div>
<div class="line"><a name="l01118"></a><span class="lineno"> 1118</span>&#160;    {</div>
<div class="line"><a name="l01119"></a><span class="lineno"> 1119</span>&#160;      d-&gt;m_out_buf_ofs += n;</div>
<div class="line"><a name="l01120"></a><span class="lineno"> 1120</span>&#160;    }</div>
<div class="line"><a name="l01121"></a><span class="lineno"> 1121</span>&#160;  }</div>
<div class="line"><a name="l01122"></a><span class="lineno"> 1122</span>&#160;</div>
<div class="line"><a name="l01123"></a><span class="lineno"> 1123</span>&#160;  <span class="keywordflow">return</span> d-&gt;m_output_flush_remaining;</div>
<div class="line"><a name="l01124"></a><span class="lineno"> 1124</span>&#160;}</div>
<div class="line"><a name="l01125"></a><span class="lineno"> 1125</span>&#160;</div>
<div class="line"><a name="l01126"></a><span class="lineno"> 1126</span>&#160;<span class="preprocessor">#define TDEFL_READ_UNALIGNED_WORD(p) *(const mz_uint16*)(p)</span></div>
<div class="line"><a name="l01127"></a><span class="lineno"> 1127</span>&#160;<span class="preprocessor"></span><span class="keyword">static</span> mz_bool tdefl_compress_fast(tdefl_compressor *d)</div>
<div class="line"><a name="l01128"></a><span class="lineno"> 1128</span>&#160;{</div>
<div class="line"><a name="l01129"></a><span class="lineno"> 1129</span>&#160;  <span class="comment">// Faster, minimally featured LZRW1-style match+parse loop with better register utilization. Intended for applications where raw throughput is valued more highly than ratio.</span></div>
<div class="line"><a name="l01130"></a><span class="lineno"> 1130</span>&#160;  mz_uint lookahead_pos = d-&gt;m_lookahead_pos, lookahead_size = d-&gt;m_lookahead_size, dict_size = d-&gt;m_dict_size, total_lz_bytes = d-&gt;m_total_lz_bytes, num_flags_left = d-&gt;m_num_flags_left;</div>
<div class="line"><a name="l01131"></a><span class="lineno"> 1131</span>&#160;  mz_uint8 *pLZ_code_buf = d-&gt;m_pLZ_code_buf, *pLZ_flags = d-&gt;m_pLZ_flags;</div>
<div class="line"><a name="l01132"></a><span class="lineno"> 1132</span>&#160;  mz_uint cur_pos = lookahead_pos &amp; TDEFL_LZ_DICT_SIZE_MASK;</div>
<div class="line"><a name="l01133"></a><span class="lineno"> 1133</span>&#160;</div>
<div class="line"><a name="l01134"></a><span class="lineno"> 1134</span>&#160;  <span class="keywordflow">while</span> ((d-&gt;m_src_buf_left) || ((d-&gt;m_flush) &amp;&amp; (lookahead_size)))</div>
<div class="line"><a name="l01135"></a><span class="lineno"> 1135</span>&#160;  {</div>
<div class="line"><a name="l01136"></a><span class="lineno"> 1136</span>&#160;    <span class="keyword">const</span> mz_uint TDEFL_COMP_FAST_LOOKAHEAD_SIZE = 4096;</div>
<div class="line"><a name="l01137"></a><span class="lineno"> 1137</span>&#160;    mz_uint dst_pos = (lookahead_pos + lookahead_size) &amp; TDEFL_LZ_DICT_SIZE_MASK;</div>
<div class="line"><a name="l01138"></a><span class="lineno"> 1138</span>&#160;    mz_uint num_bytes_to_process = (mz_uint)MZ_MIN(d-&gt;m_src_buf_left, TDEFL_COMP_FAST_LOOKAHEAD_SIZE - lookahead_size);</div>
<div class="line"><a name="l01139"></a><span class="lineno"> 1139</span>&#160;    d-&gt;m_src_buf_left -= num_bytes_to_process;</div>
<div class="line"><a name="l01140"></a><span class="lineno"> 1140</span>&#160;    lookahead_size += num_bytes_to_process;</div>
<div class="line"><a name="l01141"></a><span class="lineno"> 1141</span>&#160;</div>
<div class="line"><a name="l01142"></a><span class="lineno"> 1142</span>&#160;    <span class="keywordflow">while</span> (num_bytes_to_process)</div>
<div class="line"><a name="l01143"></a><span class="lineno"> 1143</span>&#160;    {</div>
<div class="line"><a name="l01144"></a><span class="lineno"> 1144</span>&#160;      mz_uint32 n = MZ_MIN(TDEFL_LZ_DICT_SIZE - dst_pos, num_bytes_to_process);</div>
<div class="line"><a name="l01145"></a><span class="lineno"> 1145</span>&#160;      memcpy(d-&gt;m_dict + dst_pos, d-&gt;m_pSrc, n);</div>
<div class="line"><a name="l01146"></a><span class="lineno"> 1146</span>&#160;      <span class="keywordflow">if</span> (dst_pos &lt; (TDEFL_MAX_MATCH_LEN - 1))</div>
<div class="line"><a name="l01147"></a><span class="lineno"> 1147</span>&#160;        memcpy(d-&gt;m_dict + TDEFL_LZ_DICT_SIZE + dst_pos, d-&gt;m_pSrc, MZ_MIN(n, (TDEFL_MAX_MATCH_LEN - 1) - dst_pos));</div>
<div class="line"><a name="l01148"></a><span class="lineno"> 1148</span>&#160;      d-&gt;m_pSrc += n;</div>
<div class="line"><a name="l01149"></a><span class="lineno"> 1149</span>&#160;      dst_pos = (dst_pos + n) &amp; TDEFL_LZ_DICT_SIZE_MASK;</div>
<div class="line"><a name="l01150"></a><span class="lineno"> 1150</span>&#160;      num_bytes_to_process -= n;</div>
<div class="line"><a name="l01151"></a><span class="lineno"> 1151</span>&#160;    }</div>
<div class="line"><a name="l01152"></a><span class="lineno"> 1152</span>&#160;</div>
<div class="line"><a name="l01153"></a><span class="lineno"> 1153</span>&#160;    dict_size = MZ_MIN(TDEFL_LZ_DICT_SIZE - lookahead_size, dict_size);</div>
<div class="line"><a name="l01154"></a><span class="lineno"> 1154</span>&#160;    <span class="keywordflow">if</span> ((!d-&gt;m_flush) &amp;&amp; (lookahead_size &lt; TDEFL_COMP_FAST_LOOKAHEAD_SIZE)) <span class="keywordflow">break</span>;</div>
<div class="line"><a name="l01155"></a><span class="lineno"> 1155</span>&#160;</div>
<div class="line"><a name="l01156"></a><span class="lineno"> 1156</span>&#160;    <span class="keywordflow">while</span> (lookahead_size &gt;= 4)</div>
<div class="line"><a name="l01157"></a><span class="lineno"> 1157</span>&#160;    {</div>
<div class="line"><a name="l01158"></a><span class="lineno"> 1158</span>&#160;      mz_uint cur_match_dist, cur_match_len = 1;</div>
<div class="line"><a name="l01159"></a><span class="lineno"> 1159</span>&#160;      mz_uint8 *pCur_dict = d-&gt;m_dict + cur_pos;</div>
<div class="line"><a name="l01160"></a><span class="lineno"> 1160</span>&#160;      mz_uint first_trigram = (*(<span class="keyword">const</span> mz_uint32 *)pCur_dict) &amp; 0xFFFFFF;</div>
<div class="line"><a name="l01161"></a><span class="lineno"> 1161</span>&#160;      mz_uint hash = (first_trigram ^ (first_trigram &gt;&gt; (24 - (TDEFL_LZ_HASH_BITS - 8)))) &amp; TDEFL_LEVEL1_HASH_SIZE_MASK;</div>
<div class="line"><a name="l01162"></a><span class="lineno"> 1162</span>&#160;      mz_uint probe_pos = d-&gt;m_hash[hash];</div>
<div class="line"><a name="l01163"></a><span class="lineno"> 1163</span>&#160;      d-&gt;m_hash[hash] = (mz_uint16)lookahead_pos;</div>
<div class="line"><a name="l01164"></a><span class="lineno"> 1164</span>&#160;</div>
<div class="line"><a name="l01165"></a><span class="lineno"> 1165</span>&#160;      <span class="keywordflow">if</span> (((cur_match_dist = (mz_uint16)(lookahead_pos - probe_pos)) &lt;= dict_size) &amp;&amp;</div>
<div class="line"><a name="l01166"></a><span class="lineno"> 1166</span>&#160;              ((*(<span class="keyword">const</span> mz_uint32 *)(d-&gt;m_dict + (probe_pos &amp;= TDEFL_LZ_DICT_SIZE_MASK)) &amp; 0xFFFFFF) == first_trigram))</div>
<div class="line"><a name="l01167"></a><span class="lineno"> 1167</span>&#160;      {</div>
<div class="line"><a name="l01168"></a><span class="lineno"> 1168</span>&#160;        <span class="keyword">const</span> mz_uint16 *p = (<span class="keyword">const</span> mz_uint16 *)pCur_dict;</div>
<div class="line"><a name="l01169"></a><span class="lineno"> 1169</span>&#160;        <span class="keyword">const</span> mz_uint16 *q = (<span class="keyword">const</span> mz_uint16 *)(d-&gt;m_dict + probe_pos);</div>
<div class="line"><a name="l01170"></a><span class="lineno"> 1170</span>&#160;        mz_uint32 probe_len = 32;</div>
<div class="line"><a name="l01171"></a><span class="lineno"> 1171</span>&#160;        <span class="keywordflow">do</span> { } <span class="keywordflow">while</span> ( (TDEFL_READ_UNALIGNED_WORD(++p) == TDEFL_READ_UNALIGNED_WORD(++q)) &amp;&amp; (TDEFL_READ_UNALIGNED_WORD(++p) == TDEFL_READ_UNALIGNED_WORD(++q)) &amp;&amp;</div>
<div class="line"><a name="l01172"></a><span class="lineno"> 1172</span>&#160;          (TDEFL_READ_UNALIGNED_WORD(++p) == TDEFL_READ_UNALIGNED_WORD(++q)) &amp;&amp; (TDEFL_READ_UNALIGNED_WORD(++p) == TDEFL_READ_UNALIGNED_WORD(++q)) &amp;&amp; (--probe_len &gt; 0) );</div>
<div class="line"><a name="l01173"></a><span class="lineno"> 1173</span>&#160;        cur_match_len = ((mz_uint)(p - (<span class="keyword">const</span> mz_uint16 *)pCur_dict) * 2) + (mz_uint)(*(<span class="keyword">const</span> mz_uint8 *)p == *(<span class="keyword">const</span> mz_uint8 *)q);</div>
<div class="line"><a name="l01174"></a><span class="lineno"> 1174</span>&#160;        <span class="keywordflow">if</span> (!probe_len)</div>
<div class="line"><a name="l01175"></a><span class="lineno"> 1175</span>&#160;          cur_match_len = cur_match_dist ? TDEFL_MAX_MATCH_LEN : 0;</div>
<div class="line"><a name="l01176"></a><span class="lineno"> 1176</span>&#160;</div>
<div class="line"><a name="l01177"></a><span class="lineno"> 1177</span>&#160;        <span class="keywordflow">if</span> ((cur_match_len &lt; TDEFL_MIN_MATCH_LEN) || ((cur_match_len == TDEFL_MIN_MATCH_LEN) &amp;&amp; (cur_match_dist &gt;= 8U*1024U)))</div>
<div class="line"><a name="l01178"></a><span class="lineno"> 1178</span>&#160;        {</div>
<div class="line"><a name="l01179"></a><span class="lineno"> 1179</span>&#160;          cur_match_len = 1;</div>
<div class="line"><a name="l01180"></a><span class="lineno"> 1180</span>&#160;          *pLZ_code_buf++ = (mz_uint8)first_trigram;</div>
<div class="line"><a name="l01181"></a><span class="lineno"> 1181</span>&#160;          *pLZ_flags = (mz_uint8)(*pLZ_flags &gt;&gt; 1);</div>
<div class="line"><a name="l01182"></a><span class="lineno"> 1182</span>&#160;          d-&gt;m_huff_count[0][(mz_uint8)first_trigram]++;</div>
<div class="line"><a name="l01183"></a><span class="lineno"> 1183</span>&#160;        }</div>
<div class="line"><a name="l01184"></a><span class="lineno"> 1184</span>&#160;        <span class="keywordflow">else</span></div>
<div class="line"><a name="l01185"></a><span class="lineno"> 1185</span>&#160;        {</div>
<div class="line"><a name="l01186"></a><span class="lineno"> 1186</span>&#160;          mz_uint32 s0, s1;</div>
<div class="line"><a name="l01187"></a><span class="lineno"> 1187</span>&#160;          cur_match_len = MZ_MIN(cur_match_len, lookahead_size);</div>
<div class="line"><a name="l01188"></a><span class="lineno"> 1188</span>&#160;</div>
<div class="line"><a name="l01189"></a><span class="lineno"> 1189</span>&#160;          assert((cur_match_len &gt;= TDEFL_MIN_MATCH_LEN) &amp;&amp; (cur_match_dist &gt;= 1) &amp;&amp; (cur_match_dist &lt;= TDEFL_LZ_DICT_SIZE));</div>
<div class="line"><a name="l01190"></a><span class="lineno"> 1190</span>&#160;</div>
<div class="line"><a name="l01191"></a><span class="lineno"> 1191</span>&#160;          cur_match_dist--;</div>
<div class="line"><a name="l01192"></a><span class="lineno"> 1192</span>&#160;</div>
<div class="line"><a name="l01193"></a><span class="lineno"> 1193</span>&#160;          pLZ_code_buf[0] = (mz_uint8)(cur_match_len - TDEFL_MIN_MATCH_LEN);</div>
<div class="line"><a name="l01194"></a><span class="lineno"> 1194</span>&#160;          *(mz_uint16 *)(&amp;pLZ_code_buf[1]) = (mz_uint16)cur_match_dist;</div>
<div class="line"><a name="l01195"></a><span class="lineno"> 1195</span>&#160;          pLZ_code_buf += 3;</div>
<div class="line"><a name="l01196"></a><span class="lineno"> 1196</span>&#160;          *pLZ_flags = (mz_uint8)((*pLZ_flags &gt;&gt; 1) | 0x80);</div>
<div class="line"><a name="l01197"></a><span class="lineno"> 1197</span>&#160;</div>
<div class="line"><a name="l01198"></a><span class="lineno"> 1198</span>&#160;          s0 = s_tdefl_small_dist_sym[cur_match_dist &amp; 511];</div>
<div class="line"><a name="l01199"></a><span class="lineno"> 1199</span>&#160;          s1 = s_tdefl_large_dist_sym[cur_match_dist &gt;&gt; 8];</div>
<div class="line"><a name="l01200"></a><span class="lineno"> 1200</span>&#160;          d-&gt;m_huff_count[1][(cur_match_dist &lt; 512) ? s0 : s1]++;</div>
<div class="line"><a name="l01201"></a><span class="lineno"> 1201</span>&#160;</div>
<div class="line"><a name="l01202"></a><span class="lineno"> 1202</span>&#160;          d-&gt;m_huff_count[0][s_tdefl_len_sym[cur_match_len - TDEFL_MIN_MATCH_LEN]]++;</div>
<div class="line"><a name="l01203"></a><span class="lineno"> 1203</span>&#160;        }</div>
<div class="line"><a name="l01204"></a><span class="lineno"> 1204</span>&#160;      }</div>
<div class="line"><a name="l01205"></a><span class="lineno"> 1205</span>&#160;      <span class="keywordflow">else</span></div>
<div class="line"><a name="l01206"></a><span class="lineno"> 1206</span>&#160;      {</div>
<div class="line"><a name="l01207"></a><span class="lineno"> 1207</span>&#160;        *pLZ_code_buf++ = (mz_uint8)first_trigram;</div>
<div class="line"><a name="l01208"></a><span class="lineno"> 1208</span>&#160;        *pLZ_flags = (mz_uint8)(*pLZ_flags &gt;&gt; 1);</div>
<div class="line"><a name="l01209"></a><span class="lineno"> 1209</span>&#160;        d-&gt;m_huff_count[0][(mz_uint8)first_trigram]++;</div>
<div class="line"><a name="l01210"></a><span class="lineno"> 1210</span>&#160;      }</div>
<div class="line"><a name="l01211"></a><span class="lineno"> 1211</span>&#160;</div>
<div class="line"><a name="l01212"></a><span class="lineno"> 1212</span>&#160;      <span class="keywordflow">if</span> (--num_flags_left == 0) { num_flags_left = 8; pLZ_flags = pLZ_code_buf++; }</div>
<div class="line"><a name="l01213"></a><span class="lineno"> 1213</span>&#160;</div>
<div class="line"><a name="l01214"></a><span class="lineno"> 1214</span>&#160;      total_lz_bytes += cur_match_len;</div>
<div class="line"><a name="l01215"></a><span class="lineno"> 1215</span>&#160;      lookahead_pos += cur_match_len;</div>
<div class="line"><a name="l01216"></a><span class="lineno"> 1216</span>&#160;      dict_size = MZ_MIN(dict_size + cur_match_len, TDEFL_LZ_DICT_SIZE);</div>
<div class="line"><a name="l01217"></a><span class="lineno"> 1217</span>&#160;      cur_pos = (cur_pos + cur_match_len) &amp; TDEFL_LZ_DICT_SIZE_MASK;</div>
<div class="line"><a name="l01218"></a><span class="lineno"> 1218</span>&#160;      assert(lookahead_size &gt;= cur_match_len);</div>
<div class="line"><a name="l01219"></a><span class="lineno"> 1219</span>&#160;      lookahead_size -= cur_match_len;</div>
<div class="line"><a name="l01220"></a><span class="lineno"> 1220</span>&#160;</div>
<div class="line"><a name="l01221"></a><span class="lineno"> 1221</span>&#160;      <span class="keywordflow">if</span> (pLZ_code_buf &gt; &amp;d-&gt;m_lz_code_buf[TDEFL_LZ_CODE_BUF_SIZE - 8])</div>
<div class="line"><a name="l01222"></a><span class="lineno"> 1222</span>&#160;      {</div>
<div class="line"><a name="l01223"></a><span class="lineno"> 1223</span>&#160;        <span class="keywordtype">int</span> n;</div>
<div class="line"><a name="l01224"></a><span class="lineno"> 1224</span>&#160;        d-&gt;m_lookahead_pos = lookahead_pos; d-&gt;m_lookahead_size = lookahead_size; d-&gt;m_dict_size = dict_size;</div>
<div class="line"><a name="l01225"></a><span class="lineno"> 1225</span>&#160;        d-&gt;m_total_lz_bytes = total_lz_bytes; d-&gt;m_pLZ_code_buf = pLZ_code_buf; d-&gt;m_pLZ_flags = pLZ_flags; d-&gt;m_num_flags_left = num_flags_left;</div>
<div class="line"><a name="l01226"></a><span class="lineno"> 1226</span>&#160;        <span class="keywordflow">if</span> ((n = tdefl_flush_block(d, 0)) != 0)</div>
<div class="line"><a name="l01227"></a><span class="lineno"> 1227</span>&#160;          <span class="keywordflow">return</span> (n &lt; 0) ? MZ_FALSE : MZ_TRUE;</div>
<div class="line"><a name="l01228"></a><span class="lineno"> 1228</span>&#160;        total_lz_bytes = d-&gt;m_total_lz_bytes; pLZ_code_buf = d-&gt;m_pLZ_code_buf; pLZ_flags = d-&gt;m_pLZ_flags; num_flags_left = d-&gt;m_num_flags_left;</div>
<div class="line"><a name="l01229"></a><span class="lineno"> 1229</span>&#160;      }</div>
<div class="line"><a name="l01230"></a><span class="lineno"> 1230</span>&#160;    }</div>
<div class="line"><a name="l01231"></a><span class="lineno"> 1231</span>&#160;</div>
<div class="line"><a name="l01232"></a><span class="lineno"> 1232</span>&#160;    <span class="keywordflow">while</span> (lookahead_size)</div>
<div class="line"><a name="l01233"></a><span class="lineno"> 1233</span>&#160;    {</div>
<div class="line"><a name="l01234"></a><span class="lineno"> 1234</span>&#160;      mz_uint8 lit = d-&gt;m_dict[cur_pos];</div>
<div class="line"><a name="l01235"></a><span class="lineno"> 1235</span>&#160;</div>
<div class="line"><a name="l01236"></a><span class="lineno"> 1236</span>&#160;      total_lz_bytes++;</div>
<div class="line"><a name="l01237"></a><span class="lineno"> 1237</span>&#160;      *pLZ_code_buf++ = lit;</div>
<div class="line"><a name="l01238"></a><span class="lineno"> 1238</span>&#160;      *pLZ_flags = (mz_uint8)(*pLZ_flags &gt;&gt; 1);</div>
<div class="line"><a name="l01239"></a><span class="lineno"> 1239</span>&#160;      <span class="keywordflow">if</span> (--num_flags_left == 0) { num_flags_left = 8; pLZ_flags = pLZ_code_buf++; }</div>
<div class="line"><a name="l01240"></a><span class="lineno"> 1240</span>&#160;</div>
<div class="line"><a name="l01241"></a><span class="lineno"> 1241</span>&#160;      d-&gt;m_huff_count[0][lit]++;</div>
<div class="line"><a name="l01242"></a><span class="lineno"> 1242</span>&#160;</div>
<div class="line"><a name="l01243"></a><span class="lineno"> 1243</span>&#160;      lookahead_pos++;</div>
<div class="line"><a name="l01244"></a><span class="lineno"> 1244</span>&#160;      dict_size = MZ_MIN(dict_size + 1, TDEFL_LZ_DICT_SIZE);</div>
<div class="line"><a name="l01245"></a><span class="lineno"> 1245</span>&#160;      cur_pos = (cur_pos + 1) &amp; TDEFL_LZ_DICT_SIZE_MASK;</div>
<div class="line"><a name="l01246"></a><span class="lineno"> 1246</span>&#160;      lookahead_size--;</div>
<div class="line"><a name="l01247"></a><span class="lineno"> 1247</span>&#160;</div>
<div class="line"><a name="l01248"></a><span class="lineno"> 1248</span>&#160;      <span class="keywordflow">if</span> (pLZ_code_buf &gt; &amp;d-&gt;m_lz_code_buf[TDEFL_LZ_CODE_BUF_SIZE - 8])</div>
<div class="line"><a name="l01249"></a><span class="lineno"> 1249</span>&#160;      {</div>
<div class="line"><a name="l01250"></a><span class="lineno"> 1250</span>&#160;        <span class="keywordtype">int</span> n;</div>
<div class="line"><a name="l01251"></a><span class="lineno"> 1251</span>&#160;        d-&gt;m_lookahead_pos = lookahead_pos; d-&gt;m_lookahead_size = lookahead_size; d-&gt;m_dict_size = dict_size;</div>
<div class="line"><a name="l01252"></a><span class="lineno"> 1252</span>&#160;        d-&gt;m_total_lz_bytes = total_lz_bytes; d-&gt;m_pLZ_code_buf = pLZ_code_buf; d-&gt;m_pLZ_flags = pLZ_flags; d-&gt;m_num_flags_left = num_flags_left;</div>
<div class="line"><a name="l01253"></a><span class="lineno"> 1253</span>&#160;        <span class="keywordflow">if</span> ((n = tdefl_flush_block(d, 0)) != 0)</div>
<div class="line"><a name="l01254"></a><span class="lineno"> 1254</span>&#160;          <span class="keywordflow">return</span> (n &lt; 0) ? MZ_FALSE : MZ_TRUE;</div>
<div class="line"><a name="l01255"></a><span class="lineno"> 1255</span>&#160;        total_lz_bytes = d-&gt;m_total_lz_bytes; pLZ_code_buf = d-&gt;m_pLZ_code_buf; pLZ_flags = d-&gt;m_pLZ_flags; num_flags_left = d-&gt;m_num_flags_left;</div>
<div class="line"><a name="l01256"></a><span class="lineno"> 1256</span>&#160;      }</div>
<div class="line"><a name="l01257"></a><span class="lineno"> 1257</span>&#160;    }</div>
<div class="line"><a name="l01258"></a><span class="lineno"> 1258</span>&#160;  }</div>
<div class="line"><a name="l01259"></a><span class="lineno"> 1259</span>&#160;</div>
<div class="line"><a name="l01260"></a><span class="lineno"> 1260</span>&#160;  d-&gt;m_lookahead_pos = lookahead_pos; d-&gt;m_lookahead_size = lookahead_size; d-&gt;m_dict_size = dict_size;</div>
<div class="line"><a name="l01261"></a><span class="lineno"> 1261</span>&#160;  d-&gt;m_total_lz_bytes = total_lz_bytes; d-&gt;m_pLZ_code_buf = pLZ_code_buf; d-&gt;m_pLZ_flags = pLZ_flags; d-&gt;m_num_flags_left = num_flags_left;</div>
<div class="line"><a name="l01262"></a><span class="lineno"> 1262</span>&#160;  <span class="keywordflow">return</span> MZ_TRUE;</div>
<div class="line"><a name="l01263"></a><span class="lineno"> 1263</span>&#160;}</div>
<div class="line"><a name="l01264"></a><span class="lineno"> 1264</span>&#160;</div>
<div class="line"><a name="l01265"></a><span class="lineno"> 1265</span>&#160;<span class="keyword">static</span> tdefl_status tdefl_flush_output_buffer(tdefl_compressor *d)</div>
<div class="line"><a name="l01266"></a><span class="lineno"> 1266</span>&#160;{</div>
<div class="line"><a name="l01267"></a><span class="lineno"> 1267</span>&#160;  <span class="keywordflow">if</span> (d-&gt;m_pIn_buf_size)</div>
<div class="line"><a name="l01268"></a><span class="lineno"> 1268</span>&#160;  {</div>
<div class="line"><a name="l01269"></a><span class="lineno"> 1269</span>&#160;    *d-&gt;m_pIn_buf_size = d-&gt;m_pSrc - (<span class="keyword">const</span> mz_uint8 *)d-&gt;m_pIn_buf;</div>
<div class="line"><a name="l01270"></a><span class="lineno"> 1270</span>&#160;  }</div>
<div class="line"><a name="l01271"></a><span class="lineno"> 1271</span>&#160;</div>
<div class="line"><a name="l01272"></a><span class="lineno"> 1272</span>&#160;  <span class="keywordflow">if</span> (d-&gt;m_pOut_buf_size)</div>
<div class="line"><a name="l01273"></a><span class="lineno"> 1273</span>&#160;  {</div>
<div class="line"><a name="l01274"></a><span class="lineno"> 1274</span>&#160;    <span class="keywordtype">size_t</span> n = MZ_MIN(*d-&gt;m_pOut_buf_size - d-&gt;m_out_buf_ofs, d-&gt;m_output_flush_remaining);</div>
<div class="line"><a name="l01275"></a><span class="lineno"> 1275</span>&#160;    memcpy((mz_uint8 *)d-&gt;m_pOut_buf + d-&gt;m_out_buf_ofs, d-&gt;m_output_buf + d-&gt;m_output_flush_ofs, n);</div>
<div class="line"><a name="l01276"></a><span class="lineno"> 1276</span>&#160;    d-&gt;m_output_flush_ofs += (mz_uint)n;</div>
<div class="line"><a name="l01277"></a><span class="lineno"> 1277</span>&#160;    d-&gt;m_output_flush_remaining -= (mz_uint)n;</div>
<div class="line"><a name="l01278"></a><span class="lineno"> 1278</span>&#160;    d-&gt;m_out_buf_ofs += n;</div>
<div class="line"><a name="l01279"></a><span class="lineno"> 1279</span>&#160;</div>
<div class="line"><a name="l01280"></a><span class="lineno"> 1280</span>&#160;    *d-&gt;m_pOut_buf_size = d-&gt;m_out_buf_ofs;</div>
<div class="line"><a name="l01281"></a><span class="lineno"> 1281</span>&#160;  }</div>
<div class="line"><a name="l01282"></a><span class="lineno"> 1282</span>&#160;</div>
<div class="line"><a name="l01283"></a><span class="lineno"> 1283</span>&#160;  <span class="keywordflow">return</span> (d-&gt;m_finished &amp;&amp; !d-&gt;m_output_flush_remaining) ? TDEFL_STATUS_DONE : TDEFL_STATUS_OKAY;</div>
<div class="line"><a name="l01284"></a><span class="lineno"> 1284</span>&#160;}</div>
<div class="line"><a name="l01285"></a><span class="lineno"> 1285</span>&#160;</div>
<div class="line"><a name="l01286"></a><span class="lineno"> 1286</span>&#160;tdefl_status tdefl_compress(tdefl_compressor *d, <span class="keyword">const</span> <span class="keywordtype">void</span> *pIn_buf, <span class="keywordtype">size_t</span> *pIn_buf_size, <span class="keywordtype">void</span> *pOut_buf, <span class="keywordtype">size_t</span> *pOut_buf_size, tdefl_flush flush)</div>
<div class="line"><a name="l01287"></a><span class="lineno"> 1287</span>&#160;{</div>
<div class="line"><a name="l01288"></a><span class="lineno"> 1288</span>&#160;  <span class="keywordflow">if</span> (!d)</div>
<div class="line"><a name="l01289"></a><span class="lineno"> 1289</span>&#160;  {</div>
<div class="line"><a name="l01290"></a><span class="lineno"> 1290</span>&#160;    <span class="keywordflow">if</span> (pIn_buf_size) *pIn_buf_size = 0;</div>
<div class="line"><a name="l01291"></a><span class="lineno"> 1291</span>&#160;    <span class="keywordflow">if</span> (pOut_buf_size) *pOut_buf_size = 0;</div>
<div class="line"><a name="l01292"></a><span class="lineno"> 1292</span>&#160;    <a class="code" href="core_8h.html#a582bff114cf268d287f9e7548d9fe6d1">error</a>(<span class="stringliteral">&quot;TDEFL_STATUS_BAD_PARAM&quot;</span>);</div>
<div class="line"><a name="l01293"></a><span class="lineno"> 1293</span>&#160;  }</div>
<div class="line"><a name="l01294"></a><span class="lineno"> 1294</span>&#160;</div>
<div class="line"><a name="l01295"></a><span class="lineno"> 1295</span>&#160;  d-&gt;m_pIn_buf = pIn_buf; d-&gt;m_pIn_buf_size = pIn_buf_size;</div>
<div class="line"><a name="l01296"></a><span class="lineno"> 1296</span>&#160;  d-&gt;m_pOut_buf = pOut_buf; d-&gt;m_pOut_buf_size = pOut_buf_size;</div>
<div class="line"><a name="l01297"></a><span class="lineno"> 1297</span>&#160;  d-&gt;m_pSrc = (<span class="keyword">const</span> mz_uint8 *)(pIn_buf); d-&gt;m_src_buf_left = pIn_buf_size ? *pIn_buf_size : 0;</div>
<div class="line"><a name="l01298"></a><span class="lineno"> 1298</span>&#160;  d-&gt;m_out_buf_ofs = 0;</div>
<div class="line"><a name="l01299"></a><span class="lineno"> 1299</span>&#160;  d-&gt;m_flush = flush;</div>
<div class="line"><a name="l01300"></a><span class="lineno"> 1300</span>&#160;</div>
<div class="line"><a name="l01301"></a><span class="lineno"> 1301</span>&#160;  <span class="keywordflow">if</span> ( ((d-&gt;m_pPut_buf_func != NULL) == ((pOut_buf != NULL) || (pOut_buf_size != NULL))) || (d-&gt;m_prev_return_status != TDEFL_STATUS_OKAY) ||</div>
<div class="line"><a name="l01302"></a><span class="lineno"> 1302</span>&#160;        (d-&gt;m_wants_to_finish &amp;&amp; (flush != TDEFL_FINISH)) || (pIn_buf_size &amp;&amp; *pIn_buf_size &amp;&amp; !pIn_buf) || (pOut_buf_size &amp;&amp; *pOut_buf_size &amp;&amp; !pOut_buf) )</div>
<div class="line"><a name="l01303"></a><span class="lineno"> 1303</span>&#160;  {</div>
<div class="line"><a name="l01304"></a><span class="lineno"> 1304</span>&#160;    <span class="keywordflow">if</span> (pIn_buf_size) *pIn_buf_size = 0;</div>
<div class="line"><a name="l01305"></a><span class="lineno"> 1305</span>&#160;    <span class="keywordflow">if</span> (pOut_buf_size) *pOut_buf_size = 0;</div>
<div class="line"><a name="l01306"></a><span class="lineno"> 1306</span>&#160;    <a class="code" href="core_8h.html#a582bff114cf268d287f9e7548d9fe6d1">error</a>(<span class="stringliteral">&quot;TDEFL_STATUS_BAD_PARAM&quot;</span>);</div>
<div class="line"><a name="l01307"></a><span class="lineno"> 1307</span>&#160;  }</div>
<div class="line"><a name="l01308"></a><span class="lineno"> 1308</span>&#160;  d-&gt;m_wants_to_finish |= (flush == TDEFL_FINISH);</div>
<div class="line"><a name="l01309"></a><span class="lineno"> 1309</span>&#160;</div>
<div class="line"><a name="l01310"></a><span class="lineno"> 1310</span>&#160;  <span class="keywordflow">if</span> ((d-&gt;m_output_flush_remaining) || (d-&gt;m_finished))</div>
<div class="line"><a name="l01311"></a><span class="lineno"> 1311</span>&#160;    <span class="keywordflow">return</span> (d-&gt;m_prev_return_status = tdefl_flush_output_buffer(d));</div>
<div class="line"><a name="l01312"></a><span class="lineno"> 1312</span>&#160;</div>
<div class="line"><a name="l01313"></a><span class="lineno"> 1313</span>&#160;  <span class="keywordflow">if</span> (((d-&gt;m_flags &amp; TDEFL_MAX_PROBES_MASK) == 1) &amp;&amp;</div>
<div class="line"><a name="l01314"></a><span class="lineno"> 1314</span>&#160;      ((d-&gt;m_flags &amp; TDEFL_GREEDY_PARSING_FLAG) != 0) &amp;&amp;</div>
<div class="line"><a name="l01315"></a><span class="lineno"> 1315</span>&#160;      ((d-&gt;m_flags &amp; (TDEFL_FILTER_MATCHES | TDEFL_FORCE_ALL_RAW_BLOCKS | TDEFL_RLE_MATCHES)) == 0))</div>
<div class="line"><a name="l01316"></a><span class="lineno"> 1316</span>&#160;  {</div>
<div class="line"><a name="l01317"></a><span class="lineno"> 1317</span>&#160;    tdefl_compress_fast(d);</div>
<div class="line"><a name="l01318"></a><span class="lineno"> 1318</span>&#160;  }</div>
<div class="line"><a name="l01319"></a><span class="lineno"> 1319</span>&#160;  <span class="keywordflow">else</span> <a class="code" href="core_8h.html#a582bff114cf268d287f9e7548d9fe6d1">error</a>(d-&gt;m_flags);</div>
<div class="line"><a name="l01320"></a><span class="lineno"> 1320</span>&#160;</div>
<div class="line"><a name="l01321"></a><span class="lineno"> 1321</span>&#160;  <span class="keywordflow">if</span> ((d-&gt;m_flags &amp; (TDEFL_WRITE_ZLIB_HEADER | TDEFL_COMPUTE_ADLER32)) &amp;&amp; (pIn_buf))</div>
<div class="line"><a name="l01322"></a><span class="lineno"> 1322</span>&#160;    d-&gt;m_adler32 = (mz_uint32)mz_adler32(d-&gt;m_adler32, (<span class="keyword">const</span> mz_uint8 *)pIn_buf, d-&gt;m_pSrc - (<span class="keyword">const</span> mz_uint8 *)pIn_buf);</div>
<div class="line"><a name="l01323"></a><span class="lineno"> 1323</span>&#160;</div>
<div class="line"><a name="l01324"></a><span class="lineno"> 1324</span>&#160;  <span class="keywordflow">if</span> ((flush) &amp;&amp; (!d-&gt;m_lookahead_size) &amp;&amp; (!d-&gt;m_src_buf_left) &amp;&amp; (!d-&gt;m_output_flush_remaining))</div>
<div class="line"><a name="l01325"></a><span class="lineno"> 1325</span>&#160;  {</div>
<div class="line"><a name="l01326"></a><span class="lineno"> 1326</span>&#160;    tdefl_flush_block(d, flush);</div>
<div class="line"><a name="l01327"></a><span class="lineno"> 1327</span>&#160;    d-&gt;m_finished = (flush == TDEFL_FINISH);</div>
<div class="line"><a name="l01328"></a><span class="lineno"> 1328</span>&#160;    <span class="keywordflow">if</span> (flush == TDEFL_FULL_FLUSH) { MZ_CLEAR_OBJ(d-&gt;m_hash); MZ_CLEAR_OBJ(d-&gt;m_next); d-&gt;m_dict_size = 0; }</div>
<div class="line"><a name="l01329"></a><span class="lineno"> 1329</span>&#160;  }</div>
<div class="line"><a name="l01330"></a><span class="lineno"> 1330</span>&#160;</div>
<div class="line"><a name="l01331"></a><span class="lineno"> 1331</span>&#160;  tdefl_flush_output_buffer(d);</div>
<div class="line"><a name="l01332"></a><span class="lineno"> 1332</span>&#160;  <span class="keywordflow">return</span> TDEFL_STATUS_DONE;</div>
<div class="line"><a name="l01333"></a><span class="lineno"> 1333</span>&#160;}</div>
<div class="line"><a name="l01334"></a><span class="lineno"> 1334</span>&#160;</div>
<div class="line"><a name="l01335"></a><span class="lineno"> 1335</span>&#160;tdefl_status tdefl_compress_buffer(tdefl_compressor *d, <span class="keyword">const</span> <span class="keywordtype">void</span> *pIn_buf, <span class="keywordtype">size_t</span> in_buf_size, tdefl_flush flush)</div>
<div class="line"><a name="l01336"></a><span class="lineno"> 1336</span>&#160;{</div>
<div class="line"><a name="l01337"></a><span class="lineno"> 1337</span>&#160;  assert(d-&gt;m_pPut_buf_func);</div>
<div class="line"><a name="l01338"></a><span class="lineno"> 1338</span>&#160;  <span class="keywordflow">return</span> tdefl_compress(d, pIn_buf, &amp;in_buf_size, NULL, NULL, flush);</div>
<div class="line"><a name="l01339"></a><span class="lineno"> 1339</span>&#160;}</div>
<div class="line"><a name="l01340"></a><span class="lineno"> 1340</span>&#160;</div>
<div class="line"><a name="l01341"></a><span class="lineno"> 1341</span>&#160;tdefl_status tdefl_init(tdefl_compressor *d, tdefl_put_buf_func_ptr pPut_buf_func, <span class="keywordtype">void</span> *pPut_buf_user, <span class="keywordtype">int</span> flags)</div>
<div class="line"><a name="l01342"></a><span class="lineno"> 1342</span>&#160;{</div>
<div class="line"><a name="l01343"></a><span class="lineno"> 1343</span>&#160;  d-&gt;m_pPut_buf_func = pPut_buf_func; d-&gt;m_pPut_buf_user = pPut_buf_user;</div>
<div class="line"><a name="l01344"></a><span class="lineno"> 1344</span>&#160;  d-&gt;m_flags = (mz_uint)(flags); d-&gt;m_max_probes[0] = 1 + ((flags &amp; 0xFFF) + 2) / 3; d-&gt;m_greedy_parsing = (flags &amp; TDEFL_GREEDY_PARSING_FLAG) != 0;</div>
<div class="line"><a name="l01345"></a><span class="lineno"> 1345</span>&#160;  d-&gt;m_max_probes[1] = 1 + (((flags &amp; 0xFFF) &gt;&gt; 2) + 2) / 3;</div>
<div class="line"><a name="l01346"></a><span class="lineno"> 1346</span>&#160;  <span class="keywordflow">if</span> (!(flags &amp; TDEFL_NONDETERMINISTIC_PARSING_FLAG)) MZ_CLEAR_OBJ(d-&gt;m_hash);</div>
<div class="line"><a name="l01347"></a><span class="lineno"> 1347</span>&#160;  d-&gt;m_lookahead_pos = d-&gt;m_lookahead_size = d-&gt;m_dict_size = d-&gt;m_total_lz_bytes = d-&gt;m_lz_code_buf_dict_pos = d-&gt;m_bits_in = 0;</div>
<div class="line"><a name="l01348"></a><span class="lineno"> 1348</span>&#160;  d-&gt;m_output_flush_ofs = d-&gt;m_output_flush_remaining = d-&gt;m_finished = d-&gt;m_block_index = d-&gt;m_bit_buffer = d-&gt;m_wants_to_finish = 0;</div>
<div class="line"><a name="l01349"></a><span class="lineno"> 1349</span>&#160;  d-&gt;m_pLZ_code_buf = d-&gt;m_lz_code_buf + 1; d-&gt;m_pLZ_flags = d-&gt;m_lz_code_buf; d-&gt;m_num_flags_left = 8;</div>
<div class="line"><a name="l01350"></a><span class="lineno"> 1350</span>&#160;  d-&gt;m_pOutput_buf = d-&gt;m_output_buf; d-&gt;m_pOutput_buf_end = d-&gt;m_output_buf; d-&gt;m_prev_return_status = TDEFL_STATUS_OKAY;</div>
<div class="line"><a name="l01351"></a><span class="lineno"> 1351</span>&#160;  d-&gt;m_saved_match_dist = d-&gt;m_saved_match_len = d-&gt;m_saved_lit = 0; d-&gt;m_adler32 = 1;</div>
<div class="line"><a name="l01352"></a><span class="lineno"> 1352</span>&#160;  d-&gt;m_pIn_buf = NULL; d-&gt;m_pOut_buf = NULL;</div>
<div class="line"><a name="l01353"></a><span class="lineno"> 1353</span>&#160;  d-&gt;m_pIn_buf_size = NULL; d-&gt;m_pOut_buf_size = NULL;</div>
<div class="line"><a name="l01354"></a><span class="lineno"> 1354</span>&#160;  d-&gt;m_flush = TDEFL_NO_FLUSH; d-&gt;m_pSrc = NULL; d-&gt;m_src_buf_left = 0; d-&gt;m_out_buf_ofs = 0;</div>
<div class="line"><a name="l01355"></a><span class="lineno"> 1355</span>&#160;  memset(&amp;d-&gt;m_huff_count[0][0], 0, <span class="keyword">sizeof</span>(d-&gt;m_huff_count[0][0]) * TDEFL_MAX_HUFF_SYMBOLS_0);</div>
<div class="line"><a name="l01356"></a><span class="lineno"> 1356</span>&#160;  memset(&amp;d-&gt;m_huff_count[1][0], 0, <span class="keyword">sizeof</span>(d-&gt;m_huff_count[1][0]) * TDEFL_MAX_HUFF_SYMBOLS_1);</div>
<div class="line"><a name="l01357"></a><span class="lineno"> 1357</span>&#160;  <span class="keywordflow">return</span> TDEFL_STATUS_OKAY;</div>
<div class="line"><a name="l01358"></a><span class="lineno"> 1358</span>&#160;}</div>
<div class="line"><a name="l01359"></a><span class="lineno"> 1359</span>&#160;</div>
<div class="line"><a name="l01360"></a><span class="lineno"> 1360</span>&#160;mz_bool tdefl_compress_mem_to_output(<span class="keyword">const</span> <span class="keywordtype">void</span> *pBuf, <span class="keywordtype">size_t</span> buf_len, tdefl_put_buf_func_ptr pPut_buf_func, <span class="keywordtype">void</span> *pPut_buf_user, <span class="keywordtype">int</span> flags)</div>
<div class="line"><a name="l01361"></a><span class="lineno"> 1361</span>&#160;{</div>
<div class="line"><a name="l01362"></a><span class="lineno"> 1362</span>&#160;  tdefl_compressor *pComp; assert(!(((buf_len) &amp;&amp; (!pBuf)) || (!pPut_buf_func)));</div>
<div class="line"><a name="l01363"></a><span class="lineno"> 1363</span>&#160;  pComp = (tdefl_compressor*)malloc(<span class="keyword">sizeof</span>(tdefl_compressor)); assert(pComp);</div>
<div class="line"><a name="l01364"></a><span class="lineno"> 1364</span>&#160;  tdefl_init(pComp, pPut_buf_func, pPut_buf_user, flags);</div>
<div class="line"><a name="l01365"></a><span class="lineno"> 1365</span>&#160;  tdefl_compress_buffer(pComp, pBuf, buf_len, TDEFL_FINISH);</div>
<div class="line"><a name="l01366"></a><span class="lineno"> 1366</span>&#160;  free(pComp); <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line"><a name="l01367"></a><span class="lineno"> 1367</span>&#160;}</div>
<div class="line"><a name="l01368"></a><span class="lineno"> 1368</span>&#160;</div>
<div class="line"><a name="l01369"></a><span class="lineno"> 1369</span>&#160;<span class="keyword">typedef</span> <span class="keyword">struct</span></div>
<div class="line"><a name="l01370"></a><span class="lineno"> 1370</span>&#160;{</div>
<div class="line"><a name="l01371"></a><span class="lineno"> 1371</span>&#160;  <span class="keywordtype">size_t</span> m_size, m_capacity;</div>
<div class="line"><a name="l01372"></a><span class="lineno"> 1372</span>&#160;  mz_uint8 *m_pBuf;</div>
<div class="line"><a name="l01373"></a><span class="lineno"> 1373</span>&#160;  mz_bool m_expandable;</div>
<div class="line"><a name="l01374"></a><span class="lineno"> 1374</span>&#160;} tdefl_output_buffer;</div>
<div class="line"><a name="l01375"></a><span class="lineno"> 1375</span>&#160;</div>
<div class="line"><a name="l01376"></a><span class="lineno"> 1376</span>&#160;<span class="keyword">static</span> mz_bool tdefl_output_buffer_putter(<span class="keyword">const</span> <span class="keywordtype">void</span> *pBuf, <span class="keywordtype">int</span> len, <span class="keywordtype">void</span> *pUser)</div>
<div class="line"><a name="l01377"></a><span class="lineno"> 1377</span>&#160;{</div>
<div class="line"><a name="l01378"></a><span class="lineno"> 1378</span>&#160;  tdefl_output_buffer *p = (tdefl_output_buffer *)pUser;</div>
<div class="line"><a name="l01379"></a><span class="lineno"> 1379</span>&#160;  <span class="keywordtype">size_t</span> new_size = p-&gt;m_size + len;</div>
<div class="line"><a name="l01380"></a><span class="lineno"> 1380</span>&#160;  <span class="keywordflow">if</span> (new_size &gt; p-&gt;m_capacity)</div>
<div class="line"><a name="l01381"></a><span class="lineno"> 1381</span>&#160;  {</div>
<div class="line"><a name="l01382"></a><span class="lineno"> 1382</span>&#160;    <span class="keywordtype">size_t</span> new_capacity = p-&gt;m_capacity; mz_uint8 *pNew_buf; <span class="keywordflow">if</span> (!p-&gt;m_expandable) <span class="keywordflow">return</span> MZ_FALSE;</div>
<div class="line"><a name="l01383"></a><span class="lineno"> 1383</span>&#160;    <span class="keywordflow">do</span> { new_capacity = MZ_MAX(128U, new_capacity &lt;&lt; 1U); } <span class="keywordflow">while</span> (new_size &gt; new_capacity);</div>
<div class="line"><a name="l01384"></a><span class="lineno"> 1384</span>&#160;    pNew_buf = (mz_uint8*)realloc(p-&gt;m_pBuf, new_capacity); <span class="keywordflow">if</span> (!pNew_buf) <span class="keywordflow">return</span> MZ_FALSE;</div>
<div class="line"><a name="l01385"></a><span class="lineno"> 1385</span>&#160;    p-&gt;m_pBuf = pNew_buf; p-&gt;m_capacity = new_capacity;</div>
<div class="line"><a name="l01386"></a><span class="lineno"> 1386</span>&#160;  }</div>
<div class="line"><a name="l01387"></a><span class="lineno"> 1387</span>&#160;  memcpy((mz_uint8*)p-&gt;m_pBuf + p-&gt;m_size, pBuf, len); p-&gt;m_size = new_size;</div>
<div class="line"><a name="l01388"></a><span class="lineno"> 1388</span>&#160;  <span class="keywordflow">return</span> MZ_TRUE;</div>
<div class="line"><a name="l01389"></a><span class="lineno"> 1389</span>&#160;}</div>
<div class="line"><a name="l01390"></a><span class="lineno"> 1390</span>&#160;</div>
<div class="line"><a name="l01391"></a><span class="lineno"> 1391</span>&#160;<span class="keywordtype">void</span> *tdefl_compress_mem_to_heap(<span class="keyword">const</span> <span class="keywordtype">void</span> *pSrc_buf, <span class="keywordtype">size_t</span> src_buf_len, <span class="keywordtype">size_t</span> *pOut_len, <span class="keywordtype">int</span> flags)</div>
<div class="line"><a name="l01392"></a><span class="lineno"> 1392</span>&#160;{</div>
<div class="line"><a name="l01393"></a><span class="lineno"> 1393</span>&#160;  tdefl_output_buffer out_buf; MZ_CLEAR_OBJ(out_buf);</div>
<div class="line"><a name="l01394"></a><span class="lineno"> 1394</span>&#160;  <span class="keywordflow">if</span> (!pOut_len) <span class="keywordflow">return</span> MZ_FALSE; <span class="keywordflow">else</span> *pOut_len = 0;</div>
<div class="line"><a name="l01395"></a><span class="lineno"> 1395</span>&#160;  out_buf.m_expandable = MZ_TRUE;</div>
<div class="line"><a name="l01396"></a><span class="lineno"> 1396</span>&#160;  tdefl_compress_mem_to_output(pSrc_buf, src_buf_len, tdefl_output_buffer_putter, &amp;out_buf, flags);</div>
<div class="line"><a name="l01397"></a><span class="lineno"> 1397</span>&#160;  *pOut_len = out_buf.m_size; <span class="keywordflow">return</span> out_buf.m_pBuf;</div>
<div class="line"><a name="l01398"></a><span class="lineno"> 1398</span>&#160;}</div>
<div class="line"><a name="l01399"></a><span class="lineno"> 1399</span>&#160;</div>
<div class="line"><a name="l01400"></a><span class="lineno"> 1400</span>&#160;<span class="keywordtype">size_t</span> tdefl_compress_mem_to_mem(<span class="keywordtype">void</span> *pOut_buf, <span class="keywordtype">size_t</span> out_buf_len, <span class="keyword">const</span> <span class="keywordtype">void</span> *pSrc_buf, <span class="keywordtype">size_t</span> src_buf_len, <span class="keywordtype">int</span> flags)</div>
<div class="line"><a name="l01401"></a><span class="lineno"> 1401</span>&#160;{</div>
<div class="line"><a name="l01402"></a><span class="lineno"> 1402</span>&#160;  tdefl_output_buffer out_buf; MZ_CLEAR_OBJ(out_buf);</div>
<div class="line"><a name="l01403"></a><span class="lineno"> 1403</span>&#160;  <span class="keywordflow">if</span> (!pOut_buf) <span class="keywordflow">return</span> 0;</div>
<div class="line"><a name="l01404"></a><span class="lineno"> 1404</span>&#160;  out_buf.m_pBuf = (mz_uint8*)pOut_buf; out_buf.m_capacity = out_buf_len;</div>
<div class="line"><a name="l01405"></a><span class="lineno"> 1405</span>&#160;  <span class="keywordflow">if</span> (!tdefl_compress_mem_to_output(pSrc_buf, src_buf_len, tdefl_output_buffer_putter, &amp;out_buf, flags)) <span class="keywordflow">return</span> 0;</div>
<div class="line"><a name="l01406"></a><span class="lineno"> 1406</span>&#160;  <span class="keywordflow">return</span> out_buf.m_size;</div>
<div class="line"><a name="l01407"></a><span class="lineno"> 1407</span>&#160;}</div>
<div class="line"><a name="l01408"></a><span class="lineno"> 1408</span>&#160;</div>
<div class="line"><a name="l01409"></a><span class="lineno"> 1409</span>&#160;<a class="code" href="structbuffer.html">buffer&lt;byte&gt;</a> inflate(<span class="keyword">const</span> <a class="code" href="structref.html">ref&lt;byte&gt;</a>&amp; source, <span class="keywordtype">bool</span> zlib) {</div>
<div class="line"><a name="l01410"></a><span class="lineno"> 1410</span>&#160;    <a class="code" href="structbuffer.html">buffer&lt;byte&gt;</a> data; <span class="keywordtype">size_t</span> size;</div>
<div class="line"><a name="l01411"></a><span class="lineno"> 1411</span>&#160;    data.data = (byte*)tinfl_decompress_mem_to_heap(source.data, source.size, &amp;size, zlib?TINFL_FLAG_PARSE_ZLIB_HEADER:0);</div>
<div class="line"><a name="l01412"></a><span class="lineno"> 1412</span>&#160;    data.capacity=data.size=size;</div>
<div class="line"><a name="l01413"></a><span class="lineno"> 1413</span>&#160;    <span class="keywordflow">return</span> data;</div>
<div class="line"><a name="l01414"></a><span class="lineno"> 1414</span>&#160;}</div>
<div class="line"><a name="l01415"></a><span class="lineno"> 1415</span>&#160;</div>
<div class="line"><a name="l01416"></a><span class="lineno"> 1416</span>&#160;<a class="code" href="structbuffer.html">buffer&lt;byte&gt;</a> deflate(<span class="keyword">const</span> <a class="code" href="structref.html">ref&lt;byte&gt;</a>&amp; source, <span class="keywordtype">bool</span> zlib) {</div>
<div class="line"><a name="l01417"></a><span class="lineno"> 1417</span>&#160;    <a class="code" href="structbuffer.html">buffer&lt;byte&gt;</a> data; <span class="keywordtype">size_t</span> size=0;</div>
<div class="line"><a name="l01418"></a><span class="lineno"> 1418</span>&#160;    assert(source.data &amp;&amp; source.size);</div>
<div class="line"><a name="l01419"></a><span class="lineno"> 1419</span>&#160;    data.data = (byte*)tdefl_compress_mem_to_heap(source.data, source.size, &amp;size, 1|(zlib?TDEFL_WRITE_ZLIB_HEADER:0)|TDEFL_GREEDY_PARSING_FLAG);</div>
<div class="line"><a name="l01420"></a><span class="lineno"> 1420</span>&#160;    data.capacity=data.size=size;</div>
<div class="line"><a name="l01421"></a><span class="lineno"> 1421</span>&#160;    assert(data, data.size, data.data, data.capacity, size);</div>
<div class="line"><a name="l01422"></a><span class="lineno"> 1422</span>&#160;    <span class="keywordflow">return</span> data;</div>
<div class="line"><a name="l01423"></a><span class="lineno"> 1423</span>&#160;}</div>
<div class="ttc" id="string_8h_html"><div class="ttname"><a href="string_8h.html">string.h</a></div><div class="ttdoc">String manipulations (using lightweight string when possible) </div></div>
<div class="ttc" id="file_8h_html_a58a3a30b85a63ddc4b74c15de58fa682"><div class="ttname"><a href="file_8h.html#a58a3a30b85a63ddc4b74c15de58fa682">root</a></div><div class="ttdeci">const Folder &amp; root()</div><div class="ttdoc">Returns a file descriptor to the root folder. </div><div class="ttdef"><b>Definition:</b> <a href="file_8cc_source.html#l00025">file.cc:25</a></div></div>
<div class="ttc" id="structref_html"><div class="ttname"><a href="structref.html">ref&lt; byte &gt;</a></div></div>
<div class="ttc" id="structbuffer_html"><div class="ttname"><a href="structbuffer.html">buffer&lt; byte &gt;</a></div></div>
<div class="ttc" id="deflate_8h_html"><div class="ttname"><a href="deflate_8h.html">deflate.h</a></div><div class="ttdoc">DEFLATE codec (wraps public domain miniz v1.14 by Rich Geldreich) </div></div>
<div class="ttc" id="core_8h_html_a582bff114cf268d287f9e7548d9fe6d1"><div class="ttname"><a href="core_8h.html#a582bff114cf268d287f9e7548d9fe6d1">error</a></div><div class="ttdeci">void error(const Args &amp;...args) __attribute((noreturn))</div><div class="ttdoc">Logs a message to standard output and signals all threads to log their stack trace and abort...</div></div>
</div><!-- fragment --></div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="dir_bc161955dc3a3d2485839eba21420d01.html">io</a></li><li class="navelem"><b>deflate.cc</b></li>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.6 </li>
  </ul>
</div>
</body>
</html>
