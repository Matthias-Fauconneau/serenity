// TODO: MSAA, top-left rasterization rule, mouse navigation, GUI, herbaceous plants, colors, lighting, texturing, perspective
#include "process.h"
#include "window.h"
#include "display.h"
#include "text.h"
#include "matrix.h"
#include "time.h"

// An Element generated by a Production
struct Module  {
    byte symbol;
    array<float> arguments;
    operator byte() const { return symbol; }
};
string str(const Module& o) { return str(o.symbol)+"("_+str(o.arguments,',')+")"_; }
Module copy(const Module& o){return Module __(o.symbol,copy(o.arguments));}

// Abstract base class to represent expressions
struct Expression {
    virtual float evaluate(ref<float>) const = 0;
    virtual string str() const = 0;
};
string str(const Expression& o) { return o.str(); }

struct Immediate : Expression {
    float value;
    Immediate(float value):value(value){}
    float evaluate(ref<float>) const override { return value; }
    string str() const override { return ftoa(value); }
};
struct Parameter : Expression {
    int index;
    Parameter(int index):index(index){}
    float evaluate(ref<float> a) const override { return a[index]; }
    string str() const override { return "$"_+dec(index); }
};
struct Operator : Expression {
    unique<Expression> left,right;
    Operator(unique<Expression>&& left, unique<Expression>&& right):left(move(left)),right(move(right)){}
    float evaluate(ref<float> a) const override { return left->evaluate(a)*right->evaluate(a); }
    string str() const override { return left->str()+"*"_+right->str(); }
};

struct Production {
    byte symbol;
    array<unique<Expression> > arguments;
    virtual Module operator()(ref<float> parameters) const {
        Module m; m.symbol=symbol;
        for(const unique<Expression>& e: arguments) m.arguments << e->evaluate(parameters);
        return m;
    }
};
string str(const Production& o) { return o.arguments?string(str(o.symbol)+"("_+str(o.arguments,',')+")"_):string(str(o.symbol)); }

struct Rule {
    ref<byte> left; byte edge; ref<byte> right;
    /*Expression condition=Immediate(true);*/ array<Production> productions;
};
string str(const Rule& o) { return /*str(o.left)+"<"_+*/str(o.edge)/*+">"_+str(o.right)*/+" → "_+str(o.productions); }

struct LSystem {
    array<Rule> rules;
    array<Module> axiom;
    //ref<byte> ignore;

    unique<Expression> parse(const map<ref<byte>,float>& constants, const array<ref<byte> >& parameters,
                             unique<Expression>&& e, TextData& s) {
        char c = s.peek();
        if((c>='a'&&c<='z')||(c>='A'&&c<='Z')) {
            ref<byte> identifier = s.identifier();
            int i = parameters.indexOf(identifier);
            if(i>=0) return unique<Parameter>(i);
            else return unique<Immediate>(constants.at(identifier));
        } else if(c>='0'&&c<='9') { return unique<Immediate>(s.decimal());
        } else if(c=='*') { s.next(); return unique<Operator>(move(e),parse(constants,parameters,move(e),s));
        } else error(s.untilEnd());
    }

    LSystem(){}
    LSystem(ref<byte> source) {
        map<ref<byte>,float> constants;
        for(ref<byte> line: split(source,'\n')) {
            TextData s(line); if(line.contains(':')) s.until(':'); s.skip();
            if(!s) continue;
            if(line.contains('=')) {
                auto name = s.until('=');
                constants.insert(name) = toDecimal(s.untilEnd());
            } else if(find(line,"→"_)) {
                Rule rule;
                rule.edge = s.next();
                array<ref<byte>> parameters;
                if(s.match('(')) while(!s.match(')')) { parameters << s.identifier(); s.match(','); assert(s); }
                s.skip();
                s.match("→"_);
                s.skip();
                while(s) {
                    Production p;
                    p.symbol = s.next();
                    if(s.match('(')) while(!s.match(')')) {
                        unique<Expression> e;
                        while(!s.match(',') && s.peek()!=')') {
                            e = parse(constants,parameters,move(e),s);
                            s.skip();
                            assert(s);
                        }
                        p.arguments << move(e);
                    }
                    rule.productions << move(p);
                }
                rules << move(rule);
            } else {
                assert(!axiom);
                for(;s;) {
                    Module module;
                    module.symbol = s.next();
                    if(s.match('(')) while(!s.match(')')) {
                        module.arguments << s.decimal();
                        s.skip();
                        if(!s.match(',') && s.peek()!=')') error(s.untilEnd());
                    }
                    axiom << move(module);
                }
            }
        }
    }

    array<Module> generate(int level) const {
        array<Module> code = copy(axiom);
        for(int unused i: range(level)) {
            array<Module> next;
            for(uint i: range(code.size())) { const Module& c = code[i];
                array<array<Module>> matches; //bool sensitive=false;
                for(const Rule& r: rules) {
                    if(r.edge!=c.symbol) continue;
                    if(r.left || r.right) {
                        array<float> arguments;
                        if(r.left) {
                            array<byte> path;
                            for(int j=i-1; path.size()<r.left.size && j>=0; j--) {
                                const Module& c = code[j];
                                if(c==']') { while(code[j]!='[') j--; continue; } // skip brackets
                                if(c=='+' || c=='-' || c=='[' /*|| ignore.contains(c)*/) continue;
                                path << c;
                                arguments << c.arguments;
                            }
                            if(path!=r.left) continue;
                        }
                        arguments << c.arguments;
                        if(r.right) {
                            array<byte> path;
                            for(uint j=i+1; path.size()<r.right.size && j<code.size(); j++) {
                                const Module& c = code[j];
                                if(c=='[') { while(code[j]!=']') j++; continue; } // skip brackets
                                if(c=='+' || c=='-' /*|| ignore.contains(c)*/) continue;
                                path << c;
                                arguments << c.arguments;
                            }
                            if(path!=r.right) continue;
                        }
                        //if(!r.condition(arguments)) continue;
                        //if(!sensitive) matches.clear(), sensitive=true;
                        array<Module> modules;
                        for(const Production& production: r.productions) modules << production(c.arguments);
                        matches << modules;
                    } else {
                        //if(sensitive) continue;
                        //if(!r.condition(c.arguments)) continue;
                        array<Module> modules;
                        for(const Production& production: r.productions) modules << production(c.arguments);
                        matches << modules;
                        //}
                    }
                }
                    assert(matches.size()<=1);
                    //if(matches) next << copy(matches[random()%matches.size()]);
                    if(matches) next << copy(matches[0]);
                    else next << c;
            }
            code = move(next);
        }
        return code;
    }
};

/// Bracketed, Stochastic, context-sensitive, parametric L-system
struct Editor : Widget {
    Folder folder = Folder(""_,cwd());
    array<string> systems;

    Window window __(this,int2(0,0),"L-System"_);
    LSystem system;
    uint current=0, level=6; bool label=false;
    float yaw=0,pitch=0;

    struct Line { byte label; vec3 a,b; float wa,wb; };
    array<Line> lines;
    vec3 min=0,max=0;

    void openSystem(int index) { openSystem(systems[index]); }
    void openSystem(ref<byte> name) {
        system = LSystem(readFile(string(name+".l"_),folder));
        generate();
    }
    void generate() {
        lines.clear(); min=0, max=0;
        window.setTitle(string("#"_+dec(current)+"@"_+dec(level)));

        // Turtle interpretation of modules string generated by an L-system
        array<mat4> stack; array<float> lineWidthStack;
        mat4 state; float previousLineWidth=1,lineWidth=1;
        for(const Module& module : system.generate(level)) { char symbol=module.symbol;
            float a = module.arguments?module.arguments[0]*PI/180:0;
            if(symbol=='\\'||symbol=='/') state.rotateX(symbol=='\\'?a:-a);
            else if(symbol=='&'||symbol=='^') state.rotateY(symbol=='&'?a:-a);
            else if(symbol=='-' ||symbol=='+') state.rotateZ(symbol=='+'?a:-a);
            else if(symbol=='!') lineWidth=module.arguments[0];
            else if(symbol=='$') { //set Y horizontal (keeping X), Z=X×Y
                vec3 X; for(int i=0;i<3;i++) X[i]=state(i,0);
                vec3 Y = cross(vec3(1,0,0),X);
                float y = length(Y);
                if(y<0.01) continue; //X is colinear to vertical (all possible Y are already horizontal)
                Y /= y;
                assert(Y.x==0);
                vec3 Z = cross(X,Y);
                for(int i=0;i<3;i++) state(i,1)=Y[i], state(i,2)=Z[i];
            }
            else if(symbol=='[') stack << state, lineWidthStack << lineWidth;
            else if(symbol==']') state = stack.pop(), previousLineWidth = lineWidth = lineWidthStack.pop();
            else if(symbol=='f' || symbol=='F') {
                vec3 A = (state*vec3(0,0,0));
                state.translate(vec3(module.arguments[0]?:1,0,0)); //forward axis is +X
                vec3 B = (state*vec3(0,0,0));
                if(symbol=='F') lines << Line __(module,A,B,previousLineWidth,lineWidth);
                previousLineWidth=lineWidth;
                min=::min(min,B);
                max=::max(max,B);
                // Apply tropism
                vec3 X; for(int i=0;i<3;i++) X[i]=state(i,0);
                vec3 Y = cross(vec3(-1,0,0),X);
                float y = length(Y);
                if(y<0.01) continue; //X is colinear to tropism (all rotations are possible)
                assert(Y.x==0);
                state.rotate(0.22,state.inverse().normalMatrix()*Y);
            }
        }
        window.render();
    }

    Editor() {
        window.localShortcut(Escape).connect(&exit);
        window.backgroundCenter=window.backgroundColor=0xFF;

        array<string> files = folder.list(Files);
        for(string& file : files) if(endsWith(file,".l"_)) systems << string(section(file,'.'));

        //TODO : GUI
        window.localShortcut(Key(KP_Sub)).connect([this]{if(level>0) level--; generate();});
        window.localShortcut(Key(KP_Add)).connect([this]{if(level<256) level++; generate();});
        window.localShortcut(Key(KP_Divide)).connect([this]{if(current>0){current--; if(level>10) level=10;} openSystem(current);});
        window.localShortcut(Key(KP_Multiply)).connect([this]{
            if(current<systems.size()-1){current++; if(level>10) level=10; openSystem(current);}});
        window.localShortcut(Key(' ')).connect([this]{label=!label; window.render();});
        //TODO: mouse navigation
        window.localShortcut(LeftArrow).connect([this]{yaw-=PI/12; window.render();});
        window.localShortcut(RightArrow).connect([this]{yaw+=PI/12; window.render();});
        window.localShortcut(DownArrow).connect([this]{pitch-=PI/12; window.render();});
        window.localShortcut(UpArrow).connect([this]{pitch+=PI/12; window.render();});

        openSystem(systems.last());
    }

    void render(int2, int2 window) override {
         // Fit window
        mat3 fit; float scale=1; {
            mat4 view;
            view.rotateZ(PI/2); //+X (heading) is up
            if(1) { //Fit window (for normalized fractal curves)
                vec2 m=::min(view*min,view*max).xy(), M=::max(view*min,view*max).xy();
                vec2 size = M-m;
                scale = ::min(window.x/size.x,window.y/size.y)*0.5;
                fit.scale(scale);
                vec2 margin = vec2(window)/scale-size;
                fit.translate(vec2(vec2(vec2(window)/scale/2.f).x,vec2(-m+margin/2.f).y));
            } else { //Fixed size (for growing trees)
                fit.translate(vec2(window.x/2,0)); fit.scale(scale=16);
            }
        }

        // Render lines
        {
            mat4 view;
            view.rotateX(pitch); // pitch
            view.rotateY(yaw); // yaw
            view.rotateZ(PI/2); //+X (heading) is up
            for(Line line: lines) {
                vec2 a=fit*(view*line.a).xy(), b=fit*(view*line.b).xy();
                ::line(vec2(a.x,window.y-a.y),vec2(b.x,window.y-b.y),line.wa*scale,line.wb*scale);
                vec2 c = (a+b)/2.f;
                if(label) Text(string(str(line.label))).render(int2(round(c.x),round(window.y-c.y)));
            }
        }
    }
} application;
