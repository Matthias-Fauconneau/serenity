transform {
 vertex {
  attribute vec4 position;
  uniform mat4 modelViewProjectionMatrix;
  gl_Position = modelViewProjectionMatrix * position;
 }
 position {
  varying vec3 viewPos;
  vertex {
    uniform mat4 modelViewMatrix;
    viewPos = (modelViewMatrix*position).xyz;
   }
 }
}
screen {
 varying vec2 texCoords;
 vertex {
  attribute vec4 position;
  gl_Position = position;
  texCoords = (1+gl_Position.xy/gl_Position.w)/2;
 }
}

surface {
 varying vec2 vertexTexCoord;
 varying vec3 vertexNormal;
 varying float vertexAlpha;
 varying vec2 vertexLightmap;
 varying vec3 vertexColor;
 vertex {
  attribute vec2 texcoord;
  vertexTexCoord = texcoord;

  uniform mat3 normalMatrix;
  attribute vec3 normal;
  vertexNormal = normalMatrix * normal;

  attribute float alpha;
  vertexAlpha = alpha;

  attribute vec2 lightmap;
  vertexLightmap = lightmap;

  attribute vec3 color;
  vertexColor = color;

  lightgrid {
   uniform mat4 modelLightMatrix;
   vec3 lightTexCoords = (modelLightMatrix * position).xyz;
   uniform sampler3D lightGrid0; // Ambient color
   uniform sampler3D lightGrid1; // Directionnal color
   uniform sampler3D lightGrid2; // Direction
   vec3 ambient = texture(lightGrid0, lightTexCoords).rgb;
   vec3 directional = texture(lightGrid1, lightTexCoords).rgb;
   vec3 lightDirection = normalize((texture(lightGrid2, lightTexCoords).xyz*2)-1);
   uniform mat3 viewNormalMatrix;
   vertexColor.rgb *= (ambient.rgb + max(0,dot(viewNormalMatrix * lightDirection,vertexNormal))*directional.rgb);
  }
 }
 fragment {
  uniform vec3 uniformColor;
  out vec4 color;
  color = vec4(1);
 }
}

color {
 fragment {
  uniform sampler2D tex$;
  uniform mat3x2 tcMod$;
  uniform vec3 rgbGen$;
  {
   vec3 rgbGen = rgbGen$;
   vertexColor { rgbGen = vertexColor; }
   vec4 sample = vec4(rgbGen,1)*texture(tex$,tcMod$*vec3(vertexTexCoord,1));
   vertexAlpha { sample.a = vertexAlpha; }

   vec3 sfactor=vec3(1);
   sfactor_zero { sfactor=vec3(0); }
   sfactor_one {}
   sfactor_src_color { sfactor=sample.rgb; }
   sfactor_dst_color { sfactor=color.rgb; }
   sfactor_src_alpha { sfactor=vec3(sample.a); }
   sfactor_one_minus_src_alpha { sfactor=vec3(1.0-sample.a); }
   sfactor_one_minus_dst_alpha { sfactor=vec3(1.0-color.a); }
   sfactor_one_minus_dst_color { sfactor=vec3(1.0-color.rgb); }

   vec3 dfactor=vec3(0);
   dfactor_zero {}
   dfactor_one { dfactor=vec3(1); }
   dfactor_src_color { dfactor=sample.rgb; }
   dfactor_dst_color { dfactor=color.rgb; }
   dfactor_src_alpha { dfactor=vec3(sample.a); }
   dfactor_one_minus_src_alpha { dfactor=vec3(1.0-sample.a); }
   dfactor_one_minus_src_color { dfactor=vec3(1.0)-sample.rgb; }
   dfactor_src_color_plus_src_color { dfactor=2*sample.rgb; }

   color.rgb = uniformColor*sfactor*sample.rgb + dfactor*color.rgb;

   blend_zero { color.a = 0; }
   blend_one { color.a = 1; }
   blend_src_alpha { color.a = sample.a; }
   blend_one_minus_src_alpha {
    color.a = 1-sample.a;
    sfactor_src_alpha { if( sample.a < 0.5 ) discard; }
   }
   blend_one_minus_src_color_to_alpha { color.a = 1-(sample.r+sample.g+sample.b)/3; }
   blend_src_color { color.rgb = sample.rgb; }
   blend_one_minus_src_color { color.rgb = 1-sample.rgb; }
   blend_one_plus_src_color { color.rgb = 1+sample.rgb; }
   blend_src_color_plus_src_color { color.rgb = 2*sample.rgb; }
   blend_one_minus_src_color_minus_src_color { color.rgb = 1-2*sample.rgb; }
   blend_one_minus_src_color_minus_src_color_to_alpha { color.a = 1-2*(sample.r+sample.g+sample.b)/3; }
  }
 }
}

lightmap {
 fragment {
  uniform sampler2D tex$;
  color.rgb *= texture(tex$,vertexLightmap).rgb;
 }
}

vertexlight {
 fragment {
  color.rgb *= vertexColor;
 }
}

fog {
 fragment {
  uniform vec4 fog;
  color.rgba = mix(color.rgba, vec4(fog.rgb,0), min(length(viewPos)/fog.a,1));
 }
}

gamma {
 fragment {
  uniform sampler2D source;
  float sRGB(float c) { if(c>=0.0031308) return 1.055*pow(c,1/2.4)-0.055; else return 12.92*c; } // Applies sRGB compression before writing pixel
  out vec4 color;
  color.rgb = texture(source, texCoords).rgb;
  color = vec4(sRGB(color.r),sRGB(color.g),sRGB(color.b),1);
 }
}

gammaMS {
 fragment {
  uniform sampler2DMS source;
  float sRGB(float c) { if(c>=0.0031308) return 1.055*pow(c,1/2.4)-0.055; else return 12.92*c; } // Applies sRGB compression before writing pixel
  out vec4 color;
  //color.rgb = texture(source, texCoords).rgb;
  color = vec4(0);
  const int sampleCount = 8;
  ivec2 pixel = ivec2(textureSize(source)*texCoords);
  for (int i = 0; i<sampleCount; i++) {
      //float weight = 1./sampleCount; //texelFetch (sampleWeightSampler, i).r;
      vec4 sample = texelFetch(source, pixel, i);
      color += sample; // weight * sample;
  }
  color = 1./sampleCount * color;
  color = vec4(sRGB(color.r),sRGB(color.g),sRGB(color.b),1);
 }
}
