#pragma once
/// \file operation.h Abstract interface for operations run by a process manager
#include "array.h"
#include "map.h"
#include "string.h"
#include "file.h"
#include <typeinfo>
#include "data.h"

/// Reference counter to be inherited by shared objects
struct shareable {
    virtual void addUser() { ++userCount; }
    virtual uint removeUser() { return --userCount; }
    uint userCount = 1;
};

/// Abstract factory pattern (allows construction of class by names)
template <class I> struct Interface {
    struct AbstractFactory {
        /// Returns the version of this implementation
        virtual string version() abstract;
        virtual unique<I> constructNewInstance() abstract;
    };
    static map<string, AbstractFactory*> factories;
    template <class C> struct Factory : AbstractFactory {
        string version() override { return __DATE__ " " __TIME__ ""_; }
        unique<I> constructNewInstance() override { return unique<C>(); }
        Factory() { TextData s (str(typeid(C).name())); s.integer(); factories.insert(s.word(), this); }
        static Factory registerFactory;
    };
    static string version(const string& name) { return factories.at(name)->version(); }
    static unique<I> instance(const string& name) { return factories.at(name)->constructNewInstance(); }
};
template <class I> map<string,typename Interface<I>::AbstractFactory*> Interface<I>::factories __attribute((init_priority(1000)));
template <class I> template <class C> typename Interface<I>::template Factory<C> Interface<I>::Factory<C>::registerFactory __attribute((init_priority(1001)));
#define class(C,I) \
    struct C; \
    template struct Interface<I>::Factory<C>; \
    struct C : virtual I

/// Dynamic-typed value
/// \note Implemented as a String with implicit conversions and copy
struct Variant : String {
    Variant(){}
    default_move(Variant);
    Variant(String&& s) : String(move(s)) {}
    Variant(int integer) : String(dec(integer)){}
    explicit operator bool() { return size; }
    operator int() const { return *this ? toInteger(*this) : 0; }
    operator uint() const { return *this ? toInteger(*this) : 0; }
    operator float() const { return toDecimal(*this); }
    operator double() const { return toDecimal(*this); }
    operator const string&() const { return *this; }
    operator const String&() const { return *this; }
    generic operator T() const { return T((const string&)*this); } // Enables implicit conversion to any type with an implicit string constructor
};
template<> inline Variant copy(const Variant& o) { return copy((const String&)o); }
template<> inline String str(const Variant& o) { return copy(o); }
typedef map<String,Variant> Dict; /// Associative array of variants
inline Dict parseDict(TextData& s) {
    Dict dict;
    s.skip("{"_);
    for(;;) {
        if(s.match('}')) break;
        string key = s.whileNo(":|}"_);
        string value;
        if(s.match(':')) value = s.whileNo("|}"_);
        dict.insert(String(key), replace(String(value),'\\','/'));
        if(s.match('|')) continue;
        else if(s.match('}')) break;
        else error(s.untilEnd());
    }
    return dict;
}

/// Intermediate result
struct Result : shareable {
    Result(const string& name, long timestamp, Dict&& relevantArguments, String&& metadata, buffer<byte>&& data)
        : name(name), timestamp(timestamp), relevantArguments(move(relevantArguments)), metadata(move(metadata)), data(move(data)) {}
    String name; /// Unique identifier used to reference this result in rules' inputs and outputs
    int64 timestamp; /// Unix timestamp when this result finished succesfully computing [PersistentProcess: file last modified time]
    Dict relevantArguments; /// Relevant arguments (defined only by process and user)
    String metadata; /// Metadata (defined by Operation depending on inputs and arguments) [PersistentProcess: file system metadata (currently part of file name (limit to 255 bytes)]
    buffer<byte> data; /// Data for single outputs (generated by Operation depending on inputs and arguments) [PersistentProcess: file content and memory mapped when possible]
    map<String, buffer<byte>> elements; /// Data for map outputs (generated by Operation depending on inputs and arguments) [PersistentProcess: folder with one file for each element]
};
template<> inline String str(const Result& o) { return o.name+str(o.relevantArguments); }

 /// Executes an operation using inputs to compute outputs (of given sample sizes)
struct Operation {
    /// Returns which parameters affects this operation output
    virtual string parameters() const { return ""_; }
    /// Returns the desired intermediate data size in bytes for each outputs
    virtual size_t outputSize(const Dict& args unused, const ref<Result*>& inputs unused, uint index unused) { return 0; } // Unknown sizes by default
    /// Executes the operation using inputs to compute outputs
    virtual void execute(const Dict& args, const ref<Result*>& outputs, const ref<Result*>& inputs) abstract;
};

/// Convenient helper method to implement outputs
template<Type F> bool output(const ref<Result*>& outputs, uint index, const string& metadata, F data) {
    if(outputs.size>index) {
        outputs[index]->metadata = String(metadata);
        outputs[index]->data = data();
        return true;
    } else assert_(index>0);
    return false;
}

/// Convenience class to define a single input, single output operation
struct Pass : virtual Operation {
    virtual void execute(const Dict& args, Result& output, const Result& source) abstract;
    virtual void execute(const Dict& args, const ref<Result*>& outputs, const ref<Result*>& inputs) override { execute(args, *outputs[0], *inputs[0]); }
};

/*/// Convenient macro to define simple operations
#define definePass(name, type, body) \
class(name, Operation), virtual Pass { \
    virtual void execute(const Dict& args unused, Result& target, const Result& source) override { \
        target.metadata = String(type); \
        target.data = body; \
    } \
}*/
